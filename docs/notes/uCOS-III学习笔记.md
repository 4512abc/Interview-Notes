# uCOS-III学习笔记 ✏️⭐️

# 任务管理

## 1. 任务的基本概念

在任何时刻，只有一个任务得到运行，uCOS 调度器决定运行哪个任务。调度器会不断的启动、停止每一个任务，宏观看上去所有的任务都在同时在执行。每个 uCOS 任务都需要有自己的栈空间。当任务切出时，它的执行环境会被保存在该任务的栈空间中，这样当任务再次运行时，就能从堆栈中正确的恢复上次的运行环境，任务越多，需要的堆栈空间就越大，而一个系统能运行多少个任务，取决于系统的可用的 SRAM。

uCOS 中的任务采用**抢占式调度机制**，高优先级的任务可打断低优先级任务，低优先级任务必须在高优先级任务阻塞或结束后才能得到调度。



## 2. 任务调度器的基本概念

uCOS 中提供的任务调度器是**基于优先级的全抢占式调度**：在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的。系统理论上可以支持无数个优先级(0 ～ N)，优先级数值越大的任务优先级越低，(OS_CFG_PRIO_MAX - 1u) 为最低优先级，分配给空闲任务使用，一般不建议用户来使用这个优先级。一般系统默认的最大可用优先级数目为 32。

一个操作系统如果只是具备了高优先级任务能够“立即”获得处理器并得到执行的特点，那么它仍然不算是实时操作系统。因为这个**查找最高优先级任务的过程决定了调度时间是否具有确定性**。

uCOS 内核中采用**两种方法寻找最高优先级的任务**：

- 第一种是通用的方法，因为 uCOS防止 CPU 平台不支持前导零指令，就**采用 C 语言模仿前导零指令**的效果实现了快速查找到最高优先级任务的方法。

- 而第二种方法则是特殊方法，**利用硬件计算前导零指令 CLZ**，这样子一次就能知道哪一个优先级任务能够运行，这种调度算法比普通方法更快捷，但受限于平台（在 STM32 中我们就使用这种方法）。 

如果分别创建了优先级 3 、5 、8 和 11 这四个任务，任务创建成功后，调用CPU_CntLeadZeros()可以计算出 OSPrioTbl[0]第一个置 1 的位前面有 3 个 0，那么这个 3 就是我们要查找的最高优先级，至于后面还有多少个位置 1 我们都不用管，只需要找到第一个 1 即可。 

uCOS 内核中也允许创建相同优先级的任务。**相同优先级的任务采用时间片轮转方式进行调度**（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中无更高优先级就绪任务存在的情况下才有效。为了保证系统的实时性，系统**尽最大可能地保证高优先级的任务得以运行**。任务调度的原则是一旦任务状态发生了改变，并且当前运行的任务优先级小于优先级队列组中任务最高优先级时，立刻进行任务切换（除非当前系统处于中断处理程序中或禁止任务切换的状态）。



## 3. 任务状态迁移 

uCOS 系统中的每一个任务都有多种运行状态，任务间状态转移具体见下图：

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620130337.png" alt="image-20200620130325774" style="zoom:80%;" />

(1)：创建任务→就绪态（Ready）：任务创建完成后进入就绪态，表明任务已准备就绪，随时可以运行，只等待调度器进行调度。
(2)：就绪态→运行态（Running）：发生任务切换时，就绪列表中最高优先级的任务被执行，从而进入运行态。 
(3)：运行态→就绪态：有更高优先级任务创建或者恢复后，会发生任务调度，此刻就绪列表中最高优先级任务变为运行态，那么原先运行的任务由运行态变为就绪态，依然在就绪列表中，等待最高优先级的任务运行完毕继续运行原来的任务（此处可以看做是 CPU 使用权被更高优先级的任务抢占了）。
(4)：运行态→阻塞态（或者称为挂起态 Suspended）：正在运行的任务发生阻塞（挂起、延时、读信号量等待）时，该任务会从就绪列表中删除，任务状态由运行态变成阻塞态，然后发生任务切换，运行就绪列表中当前最高优先级任务。
(5)：阻塞态→就绪态：阻塞的任务被恢复后（任务恢复、延时时间超时、读信号量超时或读到信号量等），此时被恢复的任务会被加入就绪列表，从而由阻塞态变成就绪态；如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态变成运行态。 
(6) (7) (8)：就绪态、阻塞态、运行态→删除态（Delete）：任务可以通过调用 OSTaskDel() API 函数都可以将处于任何状态的任务删除，被删除后的任务将不能再次使用，关于任务的资源都会被系统回收。
(9)：删除态→就绪态：这就是创建任务的过程，一个任务将会从无到有，创建成功的任务可以参与系统的调度。
注意：此处的任务状态只是大致的任务状态而并非 uCOS 的所有任务状态，下面会具体介绍 uCOS 中具体的任务的状态。



## 4. uCOS 的任务状态 

uCOS 系统中每一任务都有多种运行状态。系统初始化完成后，创建的任务就可以在系统中竞争一定的资源，由内核进行调度。

uCOS 的任务状态通常分为以下几种： 

- **就绪**（OS_TASK_STATE_RDY）：该任务在就绪列表中，就绪的任务已经具备执行的能力，只等待调度器进行调度，新创建的任务会初始化为就绪态。 
- **延时**（OS_TASK_STATE_DLY）：该任务处于延时调度状态。 
- **等待**（OS_TASK_STATE_PEND）：任务调用 OSQPend()、OSSemPend()这类等待函数，系统就会设置一个超时时间让该任务处于等待状态，如果超时时间设置为 0，任务的状态，无限期等下去，直到事件发生。如果超时时间为 N(N>0)，在N 个时间内任务等待的事件或信号都没发生，就退出等待状态转为就绪状态。 
- **运行**（Running）：该状态表明任务正在执行，此时它占用处理器，UCOS 调度器选择运行的永远是处于最高优先级的就绪态任务，当任务被运行的一刻，它的任务状态就变成了运行态，其实运行态的任务也是处于就绪列表中的。
- **挂起**（OS_TASK_STATE_SUSPENDED）：任务通过调用OSTaskSuspend()函数能够 挂起自己或其他任务，调用OSTaskResume()是使被挂起的任务恢复运行的唯一的方法。挂起一任务意味着该任务再被恢复运行以前不能够取得CPU的使用权，类似强行暂停一个任务。
- **延时+挂起**（OS_TASK_STATE_DLY_SUSPENDED）：任务先产生一个延时，延时没结束的时候被其他任务挂起，挂起的效果叠加，当且仅当延时结束并且挂起 被恢复了，该任务才能够再次运行。
- **等待+挂起**（OS_TASK_STATE_PEND_SUSPENDED）：任务先等待一个事件或信号的发生（无限期等待），还没等待到就被其他任务挂起，挂起的效果叠加，当且仅当任务等待到事件或信号并且挂起被恢复了，该任务才能够再次运行。
- **超时等待+挂起**（OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED）：任务在指定时间内等待事件或信号的产生，但是任务已经被其他任务挂起。
- **删除**（OS_TASK_STATE_DEL）：任务被删除后的状态，任务被删除后将不再运行，除非重新创建任务。 



## 5. 常用的任务函数

1. 任务挂起函数OS_TaskSuspend()

   任务可以通过调用 OS_TaskSuspend() 函数**将处于任何状态的任务挂起**，**被挂起的任务得不到 CPU 的使用权，也不会参与调度，不管该任务具有什么优先级**。它相对于调度器而言是不可见的，除非它从挂起态中解除。

   - 如果的任务是当前任务，也就是挂起任务自身，那么需要判断一下调度器有没有被锁定，因为挂起任务自身之后，就肯定需要切换任务，而如果调度器被 锁定的话，就无法切换任务了，所以会返回错误类型 “调度器被锁”，然后退出。
   - 如果任务处于就绪状态，那么该任务能直接挂起，但是接下来**要操作就绪列表，时间是不确定的**，我们**不能将中断关闭太久，这样子会影响系统对中断的响应**，此时系统就会打开中断，但是系统又不想其他任务来影响我们操作就绪列表，
     所以系统还会**锁定调度器**，不进行任务切换，这样子就不会有任务打扰我们的操作了，然后将任务状态变为挂起态，然后调用 OS_RdyListRemove() 函数将任务从就绪列表移除，再打开调度器，然后跳出，最后才进行任务的调度。
   - 任务可以调用 OS_TaskSuspend() 这个函数来挂起任务自身，但是在挂起自身的时候**会进行一次任务上下文切换**，需要挂起自身就将任务控制块指针设置为 NULL 或 0 传递进来即可。无论任务是什么状态都可以被挂起，只要调用了OS_TaskSuspend() 这个函数就会挂起成功，不论是挂起其他任务还是挂起任务自身。

2. 任务恢复函数OSTaskResume()

   任务恢复就是**让挂起的任务重新进入就绪状态**，恢复的任务会保留挂起前的状态信息，在恢复的时候根据挂起时的状态继续运行。如果被恢复任务在所有就绪态任务中，处于最高优先级列表的第一位，那么系统将进行任务上下文的切换。

   - 如果禁用了中断延迟发布和中断中非法调用检测，那么在中断中恢复任务则是非法的，会直接返回错误类型为 “在中断中恢复任务”，并且退出。而如果使能了中断延迟发布的话呢，就可以在中断中恢复任务，因为中断延迟发布的真正操作是
     在中断发布任务中。
   - 如果使能了中断延迟发布，并且如果该函数在中断中被调用，系统就会把恢复任务命令发布到中断消息队列中，唤醒中断发布任务，在任务中恢复指定任务，并且退出。
   - OSTaskResume() 函数用于恢复挂起的任务。任务在挂起时候调用过多少次的OS_TaskSuspend() 函数，那么就需要调用多少次 OSTaskResume() 函数才能将任务恢复运行。

3. 删除任务函数OSTaskDel()

   OSTaskDel()用于删除一个任务。当一个任务删除另外一个任务时，形参为要删除任务创建时返回的任务句柄，如果是删除自身，则形参为NULL。删除的任务将从所有就绪，阻塞，挂起和事件列表中删除。

   - 在中断中删除任务则是非法的。
   - 不允许删除空闲任务。
   - 如果使能了中断延迟发布，但是要删除的目标任务是中断延迟发布任务，这也是绝对不允许的，因为使能了中断延迟发布，则代表着系统中必须有一个中断延迟发布任务处理在中断中的发布的事情。
   - 在删除任务的时候，系统还会调用用户自定义的钩子函数，用户可以通过该钩子函数进行自定义的操作。
   - 注意：删除任务并不会释放任务的堆栈空间。

4. 任务延时函数OSTimeDly() / OSTimeDlyHMSM()

   任务延时的可选选项有：

   - OS_OPT_TIME_DLY：dly 为相对时间，就是从现在起延时多长时 间 ， 到 时 钟 节 拍 总 计 数 OSTickCtr = OSTickCtr 当前 + dly 时延时结束。
   - OS_OPT_TIME_TIMEOUT：跟 OS_OPT_TIME_DLY 的作用情况一样。
   - OS_OPT_TIME_MATCH：dly 为绝对时间，就是从系统开始运行（调用 OSStart()） 时到节拍总计数OSTickCtr = dly 时延时结束。
   - OS_OPT_TIME_PERIODIC ： 周 期 性 延 时 ， 跟 OS_OPT_TIME_DLY 的作用差不多，如果是长时间延时，该选项更精准一些。

   

   OSTimeDly()在我们任务中用得非常之多，**每个任务都必须是死循环**，并且是必须要有阻塞的情况，否则低优先级的任务就无法被运行了，OSTimeDly() 函数常**用于停止当前任务的运行，延时一段时间后再运行**。

   - 延时函数**不可在中断中使用**。
   - 如果**调度器被锁，则不允许进行延时操作**。因为延时就必须进行任务的切换，所以在延时的时候不能锁定调度器
   - 需要调用OS_TickListInsert() 函数将当前任务插入到节拍列表，加入节拍列表的任务会按照延时时间进行升序排列。其中会使用到哈希算法（取余）来决定任务存储到节拍列表中的位置。

   - OSTimeDly() 使用示例：

       ```c
       void AppTask(void * p_arg)
       {
           OS_ERR err;
    while (DEF_TRUE) {
               //  这里为任务主体代码

               /* 调用相对延时函数, 阻塞1000 个tick */
               OSTimeDly(1000, OS_OPT_TIME_DLY, &err);
    }
       }
       ```
   
   
   
OSTimeDlyHMSM() 函数与 OSTimeDly() 函数的功能类似，也是用于停止当前任务进行的运行，延时一段时间后再运行，但是 OSTimeDlyHMSM() 函数会更加直观，延时多少个小时、分钟、秒、毫秒。
   
- OSTimeDlyHMSM() 使用示例：
   
     ```c
     void AppTask(void * p_arg)
     {
         OS_ERR err;
         while (DEF_TRUE) {
             //  这里为任务主体代码
     
             /* 调用延时函数, 延时1s */
             OSTimeDlyHMSM(0,0,1,0, OS_OPT_TIME_DLY, &err);
         }
     }
     ```
   
     

## 6. 任务的设计要点 

uCOS 中程序运行的上下文包括： 

- 中断服务函数
  - 中断服务函数是一种需要特别注意的上下文环境，它**运行在非任务的执行环境下**（一般为芯片的一种特殊运行模式（也被称作特权模式）），在这个上下文环境中**不能使用挂起当前任务的操作**，不允许调用任何会阻塞运行的 API 函数接口。另外需要注意的是，中断服务程序最好**保持精简短小，快进快出**，一般在中断服务函数中只做标记事件的发生，然后通知任务，让对应任务去执行相关处理，因为中断服务函数的优先级高于任何优先级的任务，如果中断处理时间过长，将会导致整个系统的任务无法正常运行。所以在设计的时候必须考虑中断的频率、中断的处理时间等重要因素，以便配合对应中断处理任务的工作。
  - uCOS 支持**中断延迟发布**，使得**原本在中断中发布的信息变成任务级发布**，这样子会使得中断服务函数的处理更加快速，屏蔽中断的时间更短，这样子能快速响应其他的中断，真正称得上实时操作系统。
- 普通任务
  - 任务看似没有什么限制程序执行的因素，似乎所有的操作都可以执行。但是做为一个优先级明确的实时系统，**如果一个任务中的程序出现了死循环操作（此处的死循环是指没有阻塞机制的任务循环体），那么比这个任务优先级低的任务都将无法执行**，当然也包括了空闲任务，因为死循环的时候，任务不会主动让出 CPU，低优先级的任务是不可能得到CPU 的使用权的，而高优先级的任务就可以抢占 CPU。这个情况在实时操作系统中是必须注意的一点，所以**在任务中不允许出现死循环**。如果一个任务只有就绪态而无阻塞态，势必会影响到其他低优先级任务的执行，所以在进行任务设计时，就应该保证任务在不活跃的时候，任务可以进入阻塞态以交出 CPU 使用权，这就需要我们自己明确知道什么情况下让任务进入阻塞态，保证低优先级任务可以正常运行。在实际设计中，一般会将紧急的处理事件的任务优先级设置得高一些。
- 空闲任务
  - 空闲任务（idle 任务）是 uCOS 系统中没有其他工作进行时自动进入的系统任务。因为处理器总是需要代码来执行——所以**至少要有一个任务处于运行态**。uCOS 为了保证这一点，当调用 OSInit() 函数进行系统初始化时，系统会自动创建一个空闲任务，空闲任务是一个非常短小的循环。**用户可以通过空闲任务钩子方式，在空闲任务上钩入自己的功能函数**。通常这个空闲任务钩子能够完成一些额外的特殊功能，例如系统运行状态的指示，系统省电模式等。**空闲任务是唯一一个不允许出现阻塞情况的任务，因为 uCOS 需要保证系统永远都有一个可运行的任务**。
  - 对于空闲任务钩子上挂接的空闲钩子函数，它应该满足以下的条件：
    -  永远不会挂起空闲任务
    - 不应该陷入死循环，需要留出部分时间用于统计系统的运行状态等



# 消息队列



# 信号量



# 互斥量



# 事件



# 软件定时器



# 任务信号量



# 任务消息队列



# 内存管理



# 中断管理