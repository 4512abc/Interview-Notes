# uCOS-III学习笔记 ✏️⭐️

# 任务管理

## 1. 任务的基本概念

在任何时刻，只有一个任务得到运行，uCOS 调度器决定运行哪个任务。调度器会不断的启动、停止每一个任务，宏观看上去所有的任务都在同时在执行。每个 uCOS 任务都需要有自己的栈空间。当任务切出时，它的执行环境会被保存在该任务的栈空间中，这样当任务再次运行时，就能从堆栈中正确的恢复上次的运行环境，任务越多，需要的堆栈空间就越大，而一个系统能运行多少个任务，取决于系统的可用的 SRAM。

uCOS 中的任务采用**抢占式调度机制**，高优先级的任务可打断低优先级任务，低优先级任务必须在高优先级任务阻塞或结束后才能得到调度。



## 2. 任务调度器的基本概念

uCOS 中提供的任务调度器是**基于优先级的全抢占式调度**：在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的。系统理论上可以支持无数个优先级(0 ～ N)，优先级数值越大的任务优先级越低，(OS_CFG_PRIO_MAX - 1u) 为最低优先级，分配给空闲任务使用，一般不建议用户来使用这个优先级。一般系统默认的最大可用优先级数目为 32。

一个操作系统如果只是具备了高优先级任务能够“立即”获得处理器并得到执行的特点，那么它仍然不算是实时操作系统。因为这个**查找最高优先级任务的过程决定了调度时间是否具有确定性**。

uCOS 内核中采用**两种方法寻找最高优先级的任务**：

- 第一种是通用的方法，因为 uCOS防止 CPU 平台不支持前导零指令，就**采用 C 语言模仿前导零指令**的效果实现了快速查找到最高优先级任务的方法。

- 而第二种方法则是特殊方法，**利用硬件计算前导零指令 CLZ**，这样子一次就能知道哪一个优先级任务能够运行，这种调度算法比普通方法更快捷，但受限于平台（在 STM32 中我们就使用这种方法）。 

如果分别创建了优先级 3 、5 、8 和 11 这四个任务，任务创建成功后，调用CPU_CntLeadZeros()可以计算出 OSPrioTbl[0]第一个置 1 的位前面有 3 个 0，那么这个 3 就是我们要查找的最高优先级，至于后面还有多少个位置 1 我们都不用管，只需要找到第一个 1 即可。 

uCOS 内核中也允许创建相同优先级的任务。**相同优先级的任务采用时间片轮转方式进行调度**（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中无更高优先级就绪任务存在的情况下才有效。为了保证系统的实时性，系统**尽最大可能地保证高优先级的任务得以运行**。任务调度的原则是一旦任务状态发生了改变，并且当前运行的任务优先级小于优先级队列组中任务最高优先级时，立刻进行任务切换（除非当前系统处于中断处理程序中或禁止任务切换的状态）。



## 3. 任务状态迁移

uCOS 系统中的每一个任务都有多种运行状态，任务间状态转移具体见下图：

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620130337.png" alt="image-20200620130325774" style="zoom:80%;" />

(1)：创建任务→就绪态（Ready）：任务创建完成后进入就绪态，表明任务已准备就绪，随时可以运行，只等待调度器进行调度。

(2)：就绪态→运行态（Running）：发生任务切换时，就绪列表中最高优先级的任务被执行，从而进入运行态。 

(3)：运行态→就绪态：有更高优先级任务创建或者恢复后，会发生任务调度，此刻就绪列表中最高优先级任务变为运行态，那么原先运行的任务由运行态变为就绪态，依然在就绪列表中，等待最高优先级的任务运行完毕继续运行原来的任务（此处可以看做是 CPU 使用权被更高优先级的任务抢占了）。

(4)：运行态→阻塞态（或者称为挂起态 Suspended）：正在运行的任务发生阻塞（挂起、延时、读信号量等待）时，该任务会从就绪列表中删除，任务状态由运行态变成阻塞态，然后发生任务切换，运行就绪列表中当前最高优先级任务。

(5)：阻塞态→就绪态：阻塞的任务被恢复后（任务恢复、延时时间超时、读信号量超时或读到信号量等），此时被恢复的任务会被加入就绪列表，从而由阻塞态变成就绪态；如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态变成运行态。 

(6) (7) (8)：就绪态、阻塞态、运行态→删除态（Delete）：任务可以通过调用 OSTaskDel() API 函数都可以将处于任何状态的任务删除，被删除后的任务将不能再次使用，关于任务的资源都会被系统回收。

(9)：删除态→就绪态：这就是创建任务的过程，一个任务将会从无到有，创建成功的任务可以参与系统的调度。
注意：此处的任务状态只是大致的任务状态而并非 uCOS 的所有任务状态，下面会具体介绍 uCOS 中具体的任务的状态。



## 4. 任务状态

uCOS 系统中每一任务都有多种运行状态。系统初始化完成后，创建的任务就可以在系统中竞争一定的资源，由内核进行调度。

uCOS 的任务状态通常分为以下几种： 

- **就绪**（OS_TASK_STATE_RDY）：该任务在就绪列表中，就绪的任务已经具备执行的能力，只等待调度器进行调度，新创建的任务会初始化为就绪态。 
- **延时**（OS_TASK_STATE_DLY）：该任务处于延时调度状态。 
- **等待**（OS_TASK_STATE_PEND）：任务调用 OSQPend()、OSSemPend()这类等待函数，系统就会设置一个超时时间让该任务处于等待状态，如果超时时间设置为 0，任务的状态，无限期等下去，直到事件发生。如果超时时间为 N(N>0)，在N 个时间内任务等待的事件或信号都没发生，就退出等待状态转为就绪状态。 
- **运行**（Running）：该状态表明任务正在执行，此时它占用处理器，UCOS 调度器选择运行的永远是处于最高优先级的就绪态任务，当任务被运行的一刻，它的任务状态就变成了运行态，其实运行态的任务也是处于就绪列表中的。
- **挂起**（OS_TASK_STATE_SUSPENDED）：任务通过调用OSTaskSuspend()函数能够 挂起自己或其他任务，调用OSTaskResume()是使被挂起的任务恢复运行的唯一的方法。挂起一任务意味着该任务再被恢复运行以前不能够取得CPU的使用权，类似强行暂停一个任务。
- **延时+挂起**（OS_TASK_STATE_DLY_SUSPENDED）：任务先产生一个延时，延时没结束的时候被其他任务挂起，挂起的效果叠加，当且仅当延时结束并且挂起 被恢复了，该任务才能够再次运行。
- **等待+挂起**（OS_TASK_STATE_PEND_SUSPENDED）：任务先等待一个事件或信号的发生（无限期等待），还没等待到就被其他任务挂起，挂起的效果叠加，当且仅当任务等待到事件或信号并且挂起被恢复了，该任务才能够再次运行。
- **超时等待+挂起**（OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED）：任务在指定时间内等待事件或信号的产生，但是任务已经被其他任务挂起。
- **删除**（OS_TASK_STATE_DEL）：任务被删除后的状态，任务被删除后将不再运行，除非重新创建任务。 



## 5. 任务的常用函数

1. 任务挂起函数OS_TaskSuspend()

   任务可以通过调用 OS_TaskSuspend() 函数**将处于任何状态的任务挂起**，**被挂起的任务得不到 CPU 的使用权，也不会参与调度，不管该任务具有什么优先级**。它相对于调度器而言是不可见的，除非它从挂起态中解除。

   - 如果的任务是当前任务，也就是挂起任务自身，那么需要判断一下调度器有没有被锁定，因为挂起任务自身之后，就肯定需要切换任务，而如果调度器被 锁定的话，就无法切换任务了，所以会返回错误类型 “调度器被锁”，然后退出。
   - 如果任务处于就绪状态，那么该任务能直接挂起，但是接下来**要操作就绪列表，时间是不确定的**，我们**不能将中断关闭太久，这样子会影响系统对中断的响应**，此时系统就会打开中断，但是系统又不想其他任务来影响我们操作就绪列表，
     所以系统还会**锁定调度器**，不进行任务切换，这样子就不会有任务打扰我们的操作了，然后将任务状态变为挂起态，然后调用 OS_RdyListRemove() 函数将任务从就绪列表移除，再打开调度器，然后跳出，最后才进行任务的调度。
   - 任务可以调用 OS_TaskSuspend() 这个函数来挂起任务自身，但是在挂起自身的时候**会进行一次任务上下文切换**，需要挂起自身就将任务控制块指针设置为 NULL 或 0 传递进来即可。无论任务是什么状态都可以被挂起，只要调用了OS_TaskSuspend() 这个函数就会挂起成功，不论是挂起其他任务还是挂起任务自身。

2. 任务恢复函数OSTaskResume()

   任务恢复就是**让挂起的任务重新进入就绪状态**，恢复的任务会保留挂起前的状态信息，在恢复的时候根据挂起时的状态继续运行。如果被恢复任务在所有就绪态任务中，处于最高优先级列表的第一位，那么系统将进行任务上下文的切换。

   - 如果禁用了中断延迟发布和中断中非法调用检测，那么在中断中恢复任务则是非法的，会直接返回错误类型为 “在中断中恢复任务”，并且退出。而如果使能了中断延迟发布的话呢，就可以在中断中恢复任务，因为中断延迟发布的真正操作是
     在中断发布任务中。
   - 如果使能了中断延迟发布，并且如果该函数在中断中被调用，系统就会把恢复任务命令发布到中断消息队列中，唤醒中断发布任务，在任务中恢复指定任务，并且退出。
   - OSTaskResume() 函数用于恢复挂起的任务。任务在挂起时候调用过多少次的OS_TaskSuspend() 函数，那么就需要调用多少次 OSTaskResume() 函数才能将任务恢复运行。

3. 删除任务函数OSTaskDel()

   OSTaskDel()用于删除一个任务。当一个任务删除另外一个任务时，形参为要删除任务创建时返回的任务句柄，如果是删除自身，则形参为NULL。删除的任务将从所有就绪，阻塞，挂起和事件列表中删除。

   - 在中断中删除任务则是非法的。
   - 不允许删除空闲任务。
   - 如果使能了中断延迟发布，但是要删除的目标任务是中断延迟发布任务，这也是绝对不允许的，因为使能了中断延迟发布，则代表着系统中必须有一个中断延迟发布任务处理在中断中的发布的事情。
   - 在删除任务的时候，系统还会调用用户自定义的钩子函数，用户可以通过该钩子函数进行自定义的操作。
   - 注意：删除任务并不会释放任务的堆栈空间。

4. 任务延时函数OSTimeDly() / OSTimeDlyHMSM()

   任务延时的可选选项有：

   - OS_OPT_TIME_DLY：dly 为相对时间，就是从现在起延时多长时 间 ， 到 时 钟 节 拍 总 计 数 OSTickCtr = OSTickCtr 当前 + dly 时延时结束。
   - OS_OPT_TIME_TIMEOUT：跟 OS_OPT_TIME_DLY 的作用情况一样。
   - OS_OPT_TIME_MATCH：dly 为绝对时间，就是从系统开始运行（调用 OSStart()） 时到节拍总计数OSTickCtr = dly 时延时结束。
   - OS_OPT_TIME_PERIODIC ： 周 期 性 延 时 ， 跟 OS_OPT_TIME_DLY 的作用差不多，如果是长时间延时，该选项更精准一些。

   

   OSTimeDly()在我们任务中用得非常之多，**每个任务都必须是死循环**，并且是必须要有阻塞的情况，否则低优先级的任务就无法被运行了，OSTimeDly() 函数常**用于停止当前任务的运行，延时一段时间后再运行**。

   - 延时函数**不可在中断中使用**。
   - 如果**调度器被锁，则不允许进行延时操作**。因为延时就必须进行任务的切换，所以在延时的时候不能锁定调度器
   - 需要调用OS_TickListInsert() 函数将当前任务插入到节拍列表，加入节拍列表的任务会按照延时时间进行升序排列。其中会使用到哈希算法（取余）来决定任务存储到节拍列表中的位置。

   - OSTimeDly() 使用示例：

       ```c
       void AppTask(void * p_arg)
       {
           OS_ERR err;
    while (DEF_TRUE) {
               //  这里为任务主体代码

               /* 调用相对延时函数, 阻塞1000 个tick */
               OSTimeDly(1000, OS_OPT_TIME_DLY, &err);
    }
       }
       ```
   
   
   
OSTimeDlyHMSM() 函数与 OSTimeDly() 函数的功能类似，也是用于停止当前任务进行的运行，延时一段时间后再运行，但是 OSTimeDlyHMSM() 函数会更加直观，延时多少个小时、分钟、秒、毫秒。
   
- OSTimeDlyHMSM() 使用示例：
   
     ```c
     void AppTask(void * p_arg)
     {
         OS_ERR err;
         while (DEF_TRUE) {
             //  这里为任务主体代码
     
             /* 调用延时函数, 延时1s */
             OSTimeDlyHMSM(0,0,1,0, OS_OPT_TIME_DLY, &err);
         }
     }
     ```
   
     

## 6. 任务的设计要点

uCOS 中程序运行的上下文包括： 

- 中断服务函数
  - 中断服务函数是一种需要特别注意的上下文环境，它**运行在非任务的执行环境下**（一般为芯片的一种特殊运行模式（也被称作特权模式）），在这个上下文环境中**不能使用挂起当前任务的操作**，不允许调用任何会阻塞运行的 API 函数接口。另外需要注意的是，中断服务程序最好**保持精简短小，快进快出**，一般在中断服务函数中只做标记事件的发生，然后通知任务，让对应任务去执行相关处理，因为中断服务函数的优先级高于任何优先级的任务，如果中断处理时间过长，将会导致整个系统的任务无法正常运行。所以在设计的时候必须考虑中断的频率、中断的处理时间等重要因素，以便配合对应中断处理任务的工作。
  - uCOS 支持**中断延迟发布**，使得**原本在中断中发布的信息变成任务级发布**，这样子会使得中断服务函数的处理更加快速，屏蔽中断的时间更短，这样子能快速响应其他的中断，真正称得上实时操作系统。
- 普通任务
  - 任务看似没有什么限制程序执行的因素，似乎所有的操作都可以执行。但是做为一个优先级明确的实时系统，**如果一个任务中的程序出现了死循环操作（此处的死循环是指没有阻塞机制的任务循环体），那么比这个任务优先级低的任务都将无法执行**，当然也包括了空闲任务，因为死循环的时候，任务不会主动让出 CPU，低优先级的任务是不可能得到CPU 的使用权的，而高优先级的任务就可以抢占 CPU。这个情况在实时操作系统中是必须注意的一点，所以**在任务中不允许出现死循环**。如果一个任务只有就绪态而无阻塞态，势必会影响到其他低优先级任务的执行，所以在进行任务设计时，就应该保证任务在不活跃的时候，任务可以进入阻塞态以交出 CPU 使用权，这就需要我们自己明确知道什么情况下让任务进入阻塞态，保证低优先级任务可以正常运行。在实际设计中，一般会将紧急的处理事件的任务优先级设置得高一些。
- 空闲任务
  - 空闲任务（idle 任务）是 uCOS 系统中没有其他工作进行时自动进入的系统任务。因为处理器总是需要代码来执行——所以**至少要有一个任务处于运行态**。uCOS 为了保证这一点，当调用 OSInit() 函数进行系统初始化时，系统会自动创建一个空闲任务，空闲任务是一个非常短小的循环。**用户可以通过空闲任务钩子方式，在空闲任务上钩入自己的功能函数**。通常这个空闲任务钩子能够完成一些额外的特殊功能，例如系统运行状态的指示，系统省电模式等。**空闲任务是唯一一个不允许出现阻塞情况的任务，因为 uCOS 需要保证系统永远都有一个可运行的任务**。
  - 对于空闲任务钩子上挂接的空闲钩子函数，它应该满足以下的条件：
    -  永远不会挂起空闲任务
    - 不应该陷入死循环，需要留出部分时间用于统计系统的运行状态等



# 消息队列

## 1. 消息队列的基本概念

消息队列可以在**任务与任务间、中断和任务间**传递信息，实现了任务接收来自其他任务或中断的**不固定长度**的消息，任务能够从队列里面读取消息，当队列中的消息是空时，读取消息的任务将被阻塞。用户还可以指定阻塞的任务时间 timeout，在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列数据有效。当队列中有新消息时，被阻塞的任务会被唤醒并处理新消息；当等待的时间超过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转为就绪态。消息队列是一种**异步**的通信方式。

通过消息队列服务，任务或中断服务程序可以将消息放入消息队列中。同样，一个或多个任务可以从消息队列中获得消息。当有多个消息发送到消息队列时，uCOS支持FIFO或者LIFO将先进入/后进入消息队列的消息先传给任务。

uCOS 中使用队列数据结构实现**任务异步通信**工作，具有如下特性：

- 消息支持**先进先出**方式排队（FIFO），支持异步读写工作方式。
- 消息支持**后进先出**方式排队（LIFO），往队首发送消息。
- 读消息队列支持**超时机制**。
- 可以允许不同长度的**任意类型消息**（因为是引用方式传递，无论多大的数据都只是一个指针）。
- **一个任务能够从任意一个消息队列接收和发送消息**。
- **多个任务能够从同一个消息队列接收和发送消息**。
- 当队列使用结束后，可以通过删除队列函数进行删除。



## 2. 消息队列的工作过程

在 uCOS-III 中定义了一个数组 OSCfg_MsgPool[OS_CFG_MSG_POOL_SIZE]，因为**在使用消息队列的时候存取消息比较频繁**，在系统初始化的时候就将这个大数组的各个元素串成**单向链表**，组成我们说的**消息池**，而这些元素我们称之为消息。

> **使用单向链表的原因**：消息的存取并不需要从链表中间， 只需在链表的首尾存取即可，单向链表即够用，使用双向链表反而更复杂。

> **使用消息池的原因**：这样的处理很快，并且共用了资源，系统中所有被创建的队列都可以从消息池中取出消息，挂载到自身的队列上，以表示消息队列拥有消息，当消息使用完毕，则又会被释放回到消息池中，其他队列也可以从中取出消息，这样的消息资源是能被系统所有的消息队列反复使用。



### 2.1 消息池初始化

在系统初始化（OSInit() ）的时候，系统就会将消息池进行初始化，其中， OS_MsgPoolInit() 函数就是用来初始化消息池的。

- 系统会将消息池里的消息逐条串成单向链表，方便管理，通过 for循环将消息池中的每个消息元素（消息）进行初始化，并且通过单链表连接起来。

- 每个消息 OS_MSG 有四个元素：

  ```c
  struct  os_msg {                   /* 消息控制块  */
      OS_MSG              *NextPtr;  /* 指向下一个可用的消息 */
      void                *MsgPtr;   /* 指向实际的消息 */
      OS_MSG_SIZE          MsgSize;  /* 记录消息的大小（以字节为单位）*/
      CPU_TS               MsgTS;    /* 记录发送消息时的时间戳 */
  };
  ```

  <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620204357.png" alt="image-20200620204353633" style="zoom:80%;" />

- OSMsgPool 是个全局变量，用来管理消息池的存取操作，它包含以下四个元素：

  ```c
  struct  os_msg_pool {                /* 消息池控制块 */
      OS_MSG              *NextPtr;    /* 指向下一个可用的消息 */
      OS_MSG_QTY           NbrFree;    /* 记录消息池中可用的消息个数 */
      OS_MSG_QTY           NbrUsed; 	 /* 记录已用的消息个数 */
      OS_MSG_QTY           NbrUsedMax; /* 记录使用的消息峰值数量 */
  };
  ```

  <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620204718.png" alt="image-20200620204716962" style="zoom:80%;" />

- 初始化完成的消息池示意图：

  <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620204941.png" alt="image-20200620204939846" style="zoom: 67%;" />

  

### 2.2 消息队列的运作机制

uCOS 的消息队列控制块由多个元素组成，**当消息队列被创建时，编译器会静态为消息队列分配对应的内存空间**（因为我们需要自己定义一个消息队列控制块），用于保存消息队列的一些信息如队列的名字，队列可用的最大消息个数，入队指针、出队指针等。在创建成功的时候，这些内存就被占用了，创建队列的时候用户指定队列的最大消息个数，无法再次更改，每个消息空间可以存放任意类型的数据。  

**任务或者中断服务程序都可以给消息队列发送消息，当发送消息时，如果队列未满，uCOS 会将从消息池中取出一个消息，将消息挂载到队列的尾部，消息中的成员变量MsgPtr 指向要发送的消息**。如果队列已满，则返回错误代码，入队失败。

**uCOS 还支持发送紧急消息，也就是我们所说的后进先出（LIFO）排队**，其过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，发送的消息会**挂载到队列的队头而非队尾**，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。

当某个任务试图读一个队列时，**可以指定一个阻塞超时时间**。在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列数据有效。当其它任务或中断服务程序往其等待的队列中写入了数据，该任务将自动由阻塞态转移为就绪态。当等待的时间超过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转移为就绪态。

当消息队列不再被使用时，可以对它进行删除操作，一旦删除操作完成，消息队列将被永久性的删除，所有关于队列的信息会被清空，直到再次创建才可使用。

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620205914.png" alt="image-20200620205909765" style="zoom:80%;" />



## 3. 消息队列的阻塞机制

在很多时候，创建的队列， 是每个任务都可以去对他进行读写操作的，但是**为了保护每个任务对消息队列进行读操作的过程**（ uCOS 队列的写操作是没有阻塞的），**必须要有阻塞机制**，在某个任务对消息队列进行读操作的时候，必须保证该任务能正常完成读操作，而不受后来的任务干扰。

假设有一个任务 A 对某个队列进行读操作的时候（也就是我们所说的出队），发现它没有消息，那么此时任务 A 有 3 个选择：

- 第一个选择：任务 A **不等待**，这样子任务 A 不会进入阻塞态；
- 第二个选择：任务 A **进入阻塞状态**，等待着消息的到来。任务 A 的等待时间由我们自己定义，比如设置 1000 个系统时钟节拍 tick 的等待，在 这 1000 个 tick 到来之前任务 A 都是处于阻塞态，当阻塞的这段时间任务 A 等到了队列的消息，那么任务 A 就会从阻塞态变成就绪态，如果此时任务 A 比当前运行的任务优先级还高，那么，任务 A 就会得到消息并且运行；假如1000 个 tick 都过去了，队列还没消息，那任务 A 就不等了，从阻塞态中唤醒，返回一个没等到消息的错误代码，然后继续执行任务 A 的其他代码。
- 第三个选择：任务 A 死等，任务 A 进入阻塞态，直到完成读取队列的消息。

假如有多个任务阻塞在一个消息队列中，那么这些阻塞的任务将**按照任务优先级进行排序**，优先级高的任务将优先获得队列的访问权。

如果发送消息的时候用户选择**广播消息**，那么在等待中的任务都会收到一样的消息。



## 4. 消息队列的应用场景

消息队列可以**应用于发送不定长消息的场合**，包括任务与任务间的消息交换，队列是uCOS 中**任务与任务间、中断与任务间主要的通讯方式**，发送到队列的消息是通过**引用方式实现**的，这意味着队列存储的是数据的地址，我们可以通过这个地址将这个数据读取出来，这样子，*无论数据量是多大，其操作时间都是一定的*，只是一个指向数据地址指针。



## 5. 消息队列的结构

uCOS 的消息队列由多个元素组成，在消息队列被创建时，需要我们自己定义消息队列（也可以称之为消息队列句柄），因为它是用于保存消息队列的一些信息的，其数据结构 **OS_Q 除了队列必须的一些基本信息外，还有 PendList 链表与 MsgQ**，为的是方便系统来管理消息队列。

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620215030.png" alt="image-20200620215029196" style="zoom:80%;" />

OS_Q 的定义：

```c
struct  os_q {                       /* 消息队列 */
                                     /* ------------------ GENERIC  MEMBERS ------------------ */
    OS_OBJ_TYPE          Type;       /* 消息队列的类型 OS_OBJ_TYPE_Q */
    CPU_CHAR            *NamePtr;    /* 消息队列的名字 */
    OS_PEND_LIST         PendList;   /* 等待消息队列的任务列表 */
#if OS_CFG_DBG_EN > 0u
    OS_Q                *DbgPrevPtr;
    OS_Q                *DbgNextPtr;
    CPU_CHAR            *DbgNamePtr;
#endif
                                     /* ------------------ SPECIFIC MEMBERS ------------------ */
    OS_MSG_Q             MsgQ;       /* 消息列表 */
};
```

OS_MSG_Q 的定义：

```c
struct  os_msg_q {                        /* OS_MSG_Q */
    OS_MSG              *InPtr;           /* 指向要插入队列的下一个OS_MSG 的指针 */
    OS_MSG              *OutPtr;          /* 指向要从队列中提取的下一个OS_MSG 的指针 */
    OS_MSG_QTY           NbrEntriesSize;  /* 队列中允许的最大消息个数 */
    OS_MSG_QTY           NbrEntries;      /* 队列中当前的消息个数 */
    OS_MSG_QTY           NbrEntriesMax;   /* 队列中的消息个数峰值 */
};
```

队列中消息也是用**单向链表**串联起来的，但**存取消息不像消息池只是从固定的一端**。队列存取消息有两种方式：

- 一种是 FIFO 模式，即先进先出，这个时候消息的存取是在单向链表的两端，一个头一个尾，存取位置可能不一样就产生了这两个输入指针和输出指针。

  <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620215725.png" alt="image-20200620215721715" style="zoom: 67%;" />

- 另一种是 LIFO 模式，后进先出，这个时候消息的存取都是在单向链表的一端，仅仅用 OutPtr 就足够指示存取的位置，当队列中已经存在比较多的消息没有处理，这个时候有个**紧急的消息**需要马上传送到其他任务去的时候就可以在发布消息的时候选择 LIFO 模式。 

  <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620215801.png" alt="image-20200620215756111" style="zoom: 67%;" />



## 6. 消息队列的常用函数

- 创建消息队列函数OSQCreate()
- 消息队列删除函数OSQDel()
- 消息队列发送函数OSQPost()
- 消息队列获取函数OSQPend()



## 7. 消息队列使用注意事项



# 信号量



# 互斥量



# 事件



# 软件定时器



# 任务信号量



# 任务消息队列



# 内存管理



# 中断管理