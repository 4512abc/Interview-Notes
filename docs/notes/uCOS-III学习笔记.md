# uCOS-III学习笔记 ✏️⭐️

# 任务管理

## 1. 任务的基本概念

在任何时刻，只有一个任务得到运行，uCOS 调度器决定运行哪个任务。调度器会不断的启动、停止每一个任务，宏观看上去所有的任务都在同时在执行。每个 uCOS 任务都需要有自己的栈空间。当任务切出时，它的执行环境会被保存在该任务的栈空间中，这样当任务再次运行时，就能从堆栈中正确的恢复上次的运行环境，任务越多，需要的堆栈空间就越大，而一个系统能运行多少个任务，取决于系统的可用的 SRAM。

uCOS 中的任务采用**抢占式调度机制**，高优先级的任务可打断低优先级任务，低优先级任务必须在高优先级任务阻塞或结束后才能得到调度。



## 2. 任务调度器的基本概念

uCOS 中提供的任务调度器是**基于优先级的全抢占式调度**：在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的。系统理论上可以支持无数个优先级(0 ～ N)，优先级数值越大的任务优先级越低，(OS_CFG_PRIO_MAX - 1u) 为最低优先级，分配给空闲任务使用，一般不建议用户来使用这个优先级。一般系统默认的最大可用优先级数目为 32。

一个操作系统如果只是具备了高优先级任务能够“立即”获得处理器并得到执行的特点，那么它仍然不算是实时操作系统。因为这个**查找最高优先级任务的过程决定了调度时间是否具有确定性**。

uCOS 内核中采用**两种方法寻找最高优先级的任务**：

- 第一种是通用的方法，因为 uCOS防止 CPU 平台不支持前导零指令，就**采用 C 语言模仿前导零指令**的效果实现了快速查找到最高优先级任务的方法。

- 而第二种方法则是特殊方法，**利用硬件计算前导零指令 CLZ**，这样子一次就能知道哪一个优先级任务能够运行，这种调度算法比普通方法更快捷，但受限于平台（在 STM32 中我们就使用这种方法）。 

如果分别创建了优先级 3 、5 、8 和 11 这四个任务，任务创建成功后，调用CPU_CntLeadZeros()可以计算出 OSPrioTbl[0]第一个置 1 的位前面有 3 个 0，那么这个 3 就是我们要查找的最高优先级，至于后面还有多少个位置 1 我们都不用管，只需要找到第一个 1 即可。 

uCOS 内核中也允许创建相同优先级的任务。**相同优先级的任务采用时间片轮转方式进行调度**（也就是通常说的分时调度器），时间片轮转调度仅在当前系统中无更高优先级就绪任务存在的情况下才有效。为了保证系统的实时性，系统**尽最大可能地保证高优先级的任务得以运行**。任务调度的原则是一旦任务状态发生了改变，并且当前运行的任务优先级小于优先级队列组中任务最高优先级时，立刻进行任务切换（除非当前系统处于中断处理程序中或禁止任务切换的状态）。



## 3. 任务状态迁移

uCOS 系统中的每一个任务都有多种运行状态，任务间状态转移具体见下图：

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620130337.png" alt="image-20200620130325774" style="zoom:80%;" />

(1)：创建任务→就绪态（Ready）：任务创建完成后进入就绪态，表明任务已准备就绪，随时可以运行，只等待调度器进行调度。

(2)：就绪态→运行态（Running）：发生任务切换时，就绪列表中最高优先级的任务被执行，从而进入运行态。 

(3)：运行态→就绪态：有更高优先级任务创建或者恢复后，会发生任务调度，此刻就绪列表中最高优先级任务变为运行态，那么原先运行的任务由运行态变为就绪态，依然在就绪列表中，等待最高优先级的任务运行完毕继续运行原来的任务（此处可以看做是 CPU 使用权被更高优先级的任务抢占了）。

(4)：运行态→阻塞态（或者称为挂起态 Suspended）：正在运行的任务发生阻塞（挂起、延时、读信号量等待）时，该任务会从就绪列表中删除，任务状态由运行态变成阻塞态，然后发生任务切换，运行就绪列表中当前最高优先级任务。

(5)：阻塞态→就绪态：阻塞的任务被恢复后（任务恢复、延时时间超时、读信号量超时或读到信号量等），此时被恢复的任务会被加入就绪列表，从而由阻塞态变成就绪态；如果此时被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，将该任务将再次转换任务状态，由就绪态变成运行态。 

(6) (7) (8)：就绪态、阻塞态、运行态→删除态（Delete）：任务可以通过调用 OSTaskDel() API 函数都可以将处于任何状态的任务删除，被删除后的任务将不能再次使用，关于任务的资源都会被系统回收。

(9)：删除态→就绪态：这就是创建任务的过程，一个任务将会从无到有，创建成功的任务可以参与系统的调度。
注意：此处的任务状态只是大致的任务状态而并非 uCOS 的所有任务状态，下面会具体介绍 uCOS 中具体的任务的状态。



## 4. 任务状态

uCOS 系统中每一任务都有多种运行状态。系统初始化完成后，创建的任务就可以在系统中竞争一定的资源，由内核进行调度。

uCOS 的任务状态通常分为以下几种： 

- **就绪**（OS_TASK_STATE_RDY）：该任务在就绪列表中，就绪的任务已经具备执行的能力，只等待调度器进行调度，新创建的任务会初始化为就绪态。 
- **延时**（OS_TASK_STATE_DLY）：该任务处于延时调度状态。 
- **等待**（OS_TASK_STATE_PEND）：任务调用 OSQPend()、OSSemPend()这类等待函数，系统就会设置一个超时时间让该任务处于等待状态，如果超时时间设置为 0，任务的状态，无限期等下去，直到事件发生。如果超时时间为 N(N>0)，在N 个时间内任务等待的事件或信号都没发生，就退出等待状态转为就绪状态。 
- **运行**（Running）：该状态表明任务正在执行，此时它占用处理器，UCOS 调度器选择运行的永远是处于最高优先级的就绪态任务，当任务被运行的一刻，它的任务状态就变成了运行态，其实运行态的任务也是处于就绪列表中的。
- **挂起**（OS_TASK_STATE_SUSPENDED）：任务通过调用OSTaskSuspend()函数能够 挂起自己或其他任务，调用OSTaskResume()是使被挂起的任务恢复运行的唯一的方法。挂起一任务意味着该任务再被恢复运行以前不能够取得CPU的使用权，类似强行暂停一个任务。
- **延时+挂起**（OS_TASK_STATE_DLY_SUSPENDED）：任务先产生一个延时，延时没结束的时候被其他任务挂起，挂起的效果叠加，当且仅当延时结束并且挂起 被恢复了，该任务才能够再次运行。
- **等待+挂起**（OS_TASK_STATE_PEND_SUSPENDED）：任务先等待一个事件或信号的发生（无限期等待），还没等待到就被其他任务挂起，挂起的效果叠加，当且仅当任务等待到事件或信号并且挂起被恢复了，该任务才能够再次运行。
- **超时等待+挂起**（OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED）：任务在指定时间内等待事件或信号的产生，但是任务已经被其他任务挂起。
- **删除**（OS_TASK_STATE_DEL）：任务被删除后的状态，任务被删除后将不再运行，除非重新创建任务。 



## 5. 任务的常用函数

### 任务挂起函数OS_TaskSuspend()

任务可以通过调用 OS_TaskSuspend() 函数**将处于任何状态的任务挂起**，**被挂起的任务得不到 CPU 的使用权，也不会参与调度，不管该任务具有什么优先级**。它相对于调度器而言是不可见的，除非它从挂起态中解除。

- 如果的任务是当前任务，也就是挂起任务自身，那么需要判断一下调度器有没有被锁定，因为挂起任务自身之后，就肯定需要切换任务，而如果调度器被 锁定的话，就无法切换任务了，所以会返回错误类型 “调度器被锁”，然后退出。
- 如果任务处于就绪状态，那么该任务能直接挂起，但是接下来**要操作就绪列表，时间是不确定的**，我们**不能将中断关闭太久，这样子会影响系统对中断的响应**，此时系统就会打开中断，但是系统又不想其他任务来影响我们操作就绪列表，
  所以系统还会**锁定调度器**，不进行任务切换，这样子就不会有任务打扰我们的操作了，然后将任务状态变为挂起态，然后调用 OS_RdyListRemove() 函数将任务从就绪列表移除，再打开调度器，然后跳出，最后才进行任务的调度。
- 任务可以调用 OS_TaskSuspend() 这个函数来挂起任务自身，但是在挂起自身的时候**会进行一次任务上下文切换**，需要挂起自身就将任务控制块指针设置为 NULL 或 0 传递进来即可。无论任务是什么状态都可以被挂起，只要调用了OS_TaskSuspend() 这个函数就会挂起成功，不论是挂起其他任务还是挂起任务自身。



### 任务恢复函数OSTaskResume()

任务恢复就是**让挂起的任务重新进入就绪状态**，恢复的任务会保留挂起前的状态信息，在恢复的时候根据挂起时的状态继续运行。如果被恢复任务在所有就绪态任务中，处于最高优先级列表的第一位，那么系统将进行任务上下文的切换。

- 如果禁用了中断延迟发布和中断中非法调用检测，那么在中断中恢复任务则是非法的，会直接返回错误类型为 “在中断中恢复任务”，并且退出。而如果使能了中断延迟发布的话呢，就可以在中断中恢复任务，因为中断延迟发布的真正操作是
  在中断发布任务中。
- 如果使能了中断延迟发布，并且如果该函数在中断中被调用，系统就会把恢复任务命令发布到中断消息队列中，唤醒中断发布任务，在任务中恢复指定任务，并且退出。
- OSTaskResume() 函数用于恢复挂起的任务。任务在挂起时候调用过多少次的OS_TaskSuspend() 函数，那么就需要调用多少次 OSTaskResume() 函数才能将任务恢复运行。



### 删除任务函数OSTaskDel()

OSTaskDel()用于删除一个任务。当一个任务删除另外一个任务时，形参为要删除任务创建时返回的任务句柄，如果是删除自身，则形参为NULL。删除的任务将从所有就绪，阻塞，挂起和事件列表中删除。

- 在中断中删除任务则是非法的。
- 不允许删除空闲任务。
- 如果使能了中断延迟发布，但是要删除的目标任务是中断延迟发布任务，这也是绝对不允许的，因为使能了中断延迟发布，则代表着系统中必须有一个中断延迟发布任务处理在中断中的发布的事情。
- 在删除任务的时候，系统还会调用用户自定义的钩子函数，用户可以通过该钩子函数进行自定义的操作。
- 注意：删除任务并不会释放任务的堆栈空间。



### 任务延时函数OSTimeDly() / OSTimeDlyHMSM()

任务延时的可选选项有：

- OS_OPT_TIME_DLY：dly 为相对时间，就是从现在起延时多长时 间 ， 到 时 钟 节 拍 总 计 数 OSTickCtr = OSTickCtr 当前 + dly 时延时结束。
- OS_OPT_TIME_TIMEOUT：跟 OS_OPT_TIME_DLY 的作用情况一样。
- OS_OPT_TIME_MATCH：dly 为绝对时间，就是从系统开始运行（调用 OSStart()） 时到节拍总计数OSTickCtr = dly 时延时结束。
- OS_OPT_TIME_PERIODIC ： 周 期 性 延 时 ， 跟 OS_OPT_TIME_DLY 的作用差不多，如果是长时间延时，该选项更精准一些。



OSTimeDly()在我们任务中用得非常之多，**每个任务都必须是死循环**，并且是必须要有阻塞的情况，否则低优先级的任务就无法被运行了，OSTimeDly() 函数常**用于停止当前任务的运行，延时一段时间后再运行**。

- 延时函数**不可在中断中使用**。
- 如果**调度器被锁，则不允许进行延时操作**。因为延时就必须进行任务的切换，所以在延时的时候不能锁定调度器
- 需要调用OS_TickListInsert() 函数将当前任务插入到节拍列表，加入节拍列表的任务会按照延时时间进行升序排列。其中会使用到哈希算法（取余）来决定任务存储到节拍列表中的位置。

- OSTimeDly() 使用示例：

    ```c
    void AppTask(void * p_arg)
    {
        OS_ERR err;
 while (DEF_TRUE) {
            //  这里为任务主体代码

            /* 调用相对延时函数, 阻塞1000 个tick */
            OSTimeDly(1000, OS_OPT_TIME_DLY, &err);
 }
    }
    ```



OSTimeDlyHMSM() 函数与 OSTimeDly() 函数的功能类似，也是用于停止当前任务进行的运行，延时一段时间后再运行，但是 OSTimeDlyHMSM() 函数会更加直观，延时多少个小时、分钟、秒、毫秒。

- OSTimeDlyHMSM() 使用示例：
  
     ```c
     void AppTask(void * p_arg)
     {
         OS_ERR err;
         while (DEF_TRUE) {
             //  这里为任务主体代码
     
             /* 调用延时函数, 延时1s */
             OSTimeDlyHMSM(0,0,1,0, OS_OPT_TIME_DLY, &err);
         }
     }
     ```
   
     

## 6. 任务的设计要点

uCOS 中程序运行的上下文包括： 

- 中断服务函数
  - 中断服务函数是一种需要特别注意的上下文环境，它**运行在非任务的执行环境下**（一般为芯片的一种特殊运行模式（也被称作特权模式）），在这个上下文环境中**不能使用挂起当前任务的操作**，不允许调用任何会阻塞运行的 API 函数接口。另外需要注意的是，中断服务程序最好**保持精简短小，快进快出**，一般在中断服务函数中只做标记事件的发生，然后通知任务，让对应任务去执行相关处理，因为中断服务函数的优先级高于任何优先级的任务，如果中断处理时间过长，将会导致整个系统的任务无法正常运行。所以在设计的时候必须考虑中断的频率、中断的处理时间等重要因素，以便配合对应中断处理任务的工作。
  - uCOS 支持**中断延迟发布**，使得**原本在中断中发布的信息变成任务级发布**，这样子会使得中断服务函数的处理更加快速，屏蔽中断的时间更短，这样子能快速响应其他的中断，真正称得上实时操作系统。
- 普通任务
  - 任务看似没有什么限制程序执行的因素，似乎所有的操作都可以执行。但是做为一个优先级明确的实时系统，**如果一个任务中的程序出现了死循环操作（此处的死循环是指没有阻塞机制的任务循环体），那么比这个任务优先级低的任务都将无法执行**，当然也包括了空闲任务，因为死循环的时候，任务不会主动让出 CPU，低优先级的任务是不可能得到CPU 的使用权的，而高优先级的任务就可以抢占 CPU。这个情况在实时操作系统中是必须注意的一点，所以**在任务中不允许出现死循环**。如果一个任务只有就绪态而无阻塞态，势必会影响到其他低优先级任务的执行，所以在进行任务设计时，就应该保证任务在不活跃的时候，任务可以进入阻塞态以交出 CPU 使用权，这就需要我们自己明确知道什么情况下让任务进入阻塞态，保证低优先级任务可以正常运行。在实际设计中，一般会将紧急的处理事件的任务优先级设置得高一些。
- 空闲任务
  - 空闲任务（idle 任务）是 uCOS 系统中没有其他工作进行时自动进入的系统任务。因为处理器总是需要代码来执行——所以**至少要有一个任务处于运行态**。uCOS 为了保证这一点，当调用 OSInit() 函数进行系统初始化时，系统会自动创建一个空闲任务，空闲任务是一个非常短小的循环。**用户可以通过空闲任务钩子方式，在空闲任务上钩入自己的功能函数**。通常这个空闲任务钩子能够完成一些额外的特殊功能，例如系统运行状态的指示，系统省电模式等。**空闲任务是唯一一个不允许出现阻塞情况的任务，因为 uCOS 需要保证系统永远都有一个可运行的任务**。
  - 对于空闲任务钩子上挂接的空闲钩子函数，它应该满足以下的条件：
    -  永远不会挂起空闲任务
    - 不应该陷入死循环，需要留出部分时间用于统计系统的运行状态等



# 消息队列

## 1. 消息队列的基本概念

消息队列可以在**任务与任务间、中断和任务间**传递信息，实现了任务接收来自其他任务或中断的**不固定长度**的消息，任务能够从队列里面读取消息，当队列中的消息是空时，读取消息的任务将被阻塞。用户还可以指定阻塞的任务时间 timeout，在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列数据有效。当队列中有新消息时，被阻塞的任务会被唤醒并处理新消息；当等待的时间超过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转为就绪态。消息队列是一种**异步**的通信方式。

通过消息队列服务，任务或中断服务程序可以将消息放入消息队列中。同样，一个或多个任务可以从消息队列中获得消息。当有多个消息发送到消息队列时，uCOS支持FIFO或者LIFO将先进入/后进入消息队列的消息先传给任务。

uCOS 中使用队列数据结构实现**任务异步通信**工作，具有如下特性：

- 消息支持**先进先出**方式排队（FIFO），支持异步读写工作方式。
- 消息支持**后进先出**方式排队（LIFO），往队首发送消息。
- 读消息队列支持**超时机制**。
- 可以允许不同长度的**任意类型消息**（因为是引用方式传递，无论多大的数据都只是一个指针）。
- **一个任务能够从任意一个消息队列接收和发送消息**。
- **多个任务能够从同一个消息队列接收和发送消息**。
- 当队列使用结束后，可以通过删除队列函数进行删除。



## 2. 消息队列的工作过程

在 uCOS-III 中定义了一个数组 OSCfg_MsgPool[OS_CFG_MSG_POOL_SIZE]，因为**在使用消息队列的时候存取消息比较频繁**，在系统初始化的时候就将这个大数组的各个元素串成**单向链表**，组成我们说的**消息池**，而这些元素我们称之为消息。

> **使用单向链表的原因**：消息的存取并不需要从链表中间， 只需在链表的首尾存取即可，单向链表即够用，使用双向链表反而更复杂。

> **使用消息池的原因**：这样的处理很快，并且共用了资源，系统中所有被创建的队列都可以从消息池中取出消息，挂载到自身的队列上，以表示消息队列拥有消息，当消息使用完毕，则又会被释放回到消息池中，其他队列也可以从中取出消息，这样的消息资源是能被系统所有的消息队列反复使用。



### 2.1 消息池初始化

在系统初始化（OSInit() ）的时候，系统就会将消息池进行初始化，其中， OS_MsgPoolInit() 函数就是用来初始化消息池的。

- 系统会将消息池里的消息逐条串成单向链表，方便管理，通过 for循环将消息池中的每个消息元素（消息）进行初始化，并且通过单链表连接起来。

- 每个消息 OS_MSG 有四个元素：

  ```c
  struct  os_msg {                   /* 消息控制块  */
      OS_MSG              *NextPtr;  /* 指向下一个可用的消息 */
      void                *MsgPtr;   /* 指向实际的消息 */
      OS_MSG_SIZE          MsgSize;  /* 记录消息的大小（以字节为单位）*/
      CPU_TS               MsgTS;    /* 记录发送消息时的时间戳 */
  };
  ```

  <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620204357.png" alt="image-20200620204353633" style="zoom:80%;" />

- OSMsgPool 是个全局变量，用来管理消息池的存取操作，它包含以下四个元素：

  ```c
  struct  os_msg_pool {                /* 消息池控制块 */
      OS_MSG              *NextPtr;    /* 指向下一个可用的消息 */
      OS_MSG_QTY           NbrFree;    /* 记录消息池中可用的消息个数 */
      OS_MSG_QTY           NbrUsed; 	 /* 记录已用的消息个数 */
      OS_MSG_QTY           NbrUsedMax; /* 记录使用的消息峰值数量 */
  };
  ```

  <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620204718.png" alt="image-20200620204716962" style="zoom:80%;" />

- 初始化完成的消息池示意图：

  <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620204941.png" alt="image-20200620204939846" style="zoom: 67%;" />

  

### 2.2 消息队列的运作机制

uCOS 的消息队列控制块由多个元素组成，**当消息队列被创建时，编译器会静态为消息队列分配对应的内存空间**（因为我们需要自己定义一个消息队列控制块），用于保存消息队列的一些信息如队列的名字，队列可用的最大消息个数，入队指针、出队指针等。在创建成功的时候，这些内存就被占用了，创建队列的时候用户指定队列的最大消息个数，无法再次更改，每个消息空间可以存放任意类型的数据。  

**任务或者中断服务程序都可以给消息队列发送消息，当发送消息时，如果队列未满，uCOS 会将从消息池中取出一个消息，将消息挂载到队列的尾部，消息中的成员变量MsgPtr 指向要发送的消息**。如果队列已满，则返回错误代码，入队失败。

**uCOS 还支持发送紧急消息，也就是我们所说的后进先出（LIFO）排队**，其过程与发送消息几乎一样，唯一的不同是，当发送紧急消息时，发送的消息会**挂载到队列的队头而非队尾**，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。

当某个任务试图读一个队列时，**可以指定一个阻塞超时时间**。在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列数据有效。当其它任务或中断服务程序往其等待的队列中写入了数据，该任务将自动由阻塞态转移为就绪态。当等待的时间超过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转移为就绪态。

当消息队列不再被使用时，可以对它进行删除操作，一旦删除操作完成，消息队列将被永久性的删除，所有关于队列的信息会被清空，直到再次创建才可使用。

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620205914.png" alt="image-20200620205909765" style="zoom:80%;" />



## 3. 消息队列的阻塞机制

在很多时候，创建的队列， 是每个任务都可以去对他进行读写操作的，但是**为了保护每个任务对消息队列进行读操作的过程**（ uCOS 队列的写操作是没有阻塞的），**必须要有阻塞机制**，在某个任务对消息队列进行读操作的时候，必须保证该任务能正常完成读操作，而不受后来的任务干扰。

假设有一个任务 A 对某个队列进行读操作的时候（也就是我们所说的出队），发现它没有消息，那么此时任务 A 有 3 个选择：

- 第一个选择：任务 A **不等待**，这样子任务 A 不会进入阻塞态；
- 第二个选择：任务 A **进入阻塞状态**，等待着消息的到来。任务 A 的等待时间由我们自己定义，比如设置 1000 个系统时钟节拍 tick 的等待，在 这 1000 个 tick 到来之前任务 A 都是处于阻塞态，当阻塞的这段时间任务 A 等到了队列的消息，那么任务 A 就会从阻塞态变成就绪态，如果此时任务 A 比当前运行的任务优先级还高，那么，任务 A 就会得到消息并且运行；假如1000 个 tick 都过去了，队列还没消息，那任务 A 就不等了，从阻塞态中唤醒，返回一个没等到消息的错误代码，然后继续执行任务 A 的其他代码。
- 第三个选择：任务 A 死等，任务 A 进入阻塞态，直到完成读取队列的消息。

假如有多个任务阻塞在一个消息队列中，那么这些阻塞的任务将**按照任务优先级进行排序**，优先级高的任务将优先获得队列的访问权。

如果发送消息的时候用户选择**广播消息**，那么在等待中的任务都会收到一样的消息。



## 4. 消息队列的应用场景

消息队列可以**应用于发送不定长消息的场合**，包括任务与任务间的消息交换，队列是uCOS 中**任务与任务间、中断与任务间主要的通讯方式**，发送到队列的消息是通过**引用方式实现**的，这意味着队列存储的是数据的地址，我们可以通过这个地址将这个数据读取出来，这样子，*无论数据量是多大，其操作时间都是一定的*，只是一个指向数据地址指针。



## 5. 消息队列的结构

uCOS 的消息队列由多个元素组成，在消息队列被创建时，需要我们自己定义消息队列（也可以称之为消息队列句柄），因为它是用于保存消息队列的一些信息的，其数据结构 **OS_Q 除了队列必须的一些基本信息外，还有 PendList 链表与 MsgQ**，为的是方便系统来管理消息队列。

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620215030.png" alt="image-20200620215029196" style="zoom:80%;" />

OS_Q 的定义：

```c
struct  os_q {                       /* 消息队列 */
                                     /* ------------------ GENERIC  MEMBERS ------------------ */
    OS_OBJ_TYPE          Type;       /* 消息队列的类型 OS_OBJ_TYPE_Q */
    CPU_CHAR            *NamePtr;    /* 消息队列的名字 */
    OS_PEND_LIST         PendList;   /* 等待消息队列的任务列表 */
#if OS_CFG_DBG_EN > 0u
    OS_Q                *DbgPrevPtr;
    OS_Q                *DbgNextPtr;
    CPU_CHAR            *DbgNamePtr;
#endif
                                     /* ------------------ SPECIFIC MEMBERS ------------------ */
    OS_MSG_Q             MsgQ;       /* 消息列表 */
};
```

OS_MSG_Q 的定义：

```c
struct  os_msg_q {                        /* OS_MSG_Q */
    OS_MSG              *InPtr;           /* 指向要插入队列的下一个OS_MSG 的指针 */
    OS_MSG              *OutPtr;          /* 指向要从队列中提取的下一个OS_MSG 的指针 */
    OS_MSG_QTY           NbrEntriesSize;  /* 队列中允许的最大消息个数 */
    OS_MSG_QTY           NbrEntries;      /* 队列中当前的消息个数 */
    OS_MSG_QTY           NbrEntriesMax;   /* 队列中的消息个数峰值 */
};
```

队列中消息也是用**单向链表**串联起来的，但**存取消息不像消息池只是从固定的一端**。队列存取消息有两种方式：

- 一种是 FIFO 模式，即先进先出，这个时候消息的存取是在单向链表的两端，一个头一个尾，存取位置可能不一样就产生了这两个输入指针和输出指针。

  <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620215725.png" alt="image-20200620215721715" style="zoom: 67%;" />

- 另一种是 LIFO 模式，后进先出，这个时候消息的存取都是在单向链表的一端，仅仅用 OutPtr 就足够指示存取的位置，当队列中已经存在比较多的消息没有处理，这个时候有个**紧急的消息**需要马上传送到其他任务去的时候就可以在发布消息的时候选择 LIFO 模式。 

  <img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200620215801.png" alt="image-20200620215756111" style="zoom: 67%;" />



## 6. 消息队列的常用函数

### 创建消息队列函数OSQCreate()

- 每创建一个新的队列都需要为其分配 RAM，在创建的时候我们需要自己定义一个消息队列结构体，其内存是由编译器自动分配的。
  
- 消息队列的阻塞列表用于记录阻塞在此消息队列上的任务。

- 定义了队列的句柄（结构体）并不等于创建了队列，创建队列必须时调用消息队列创建函数进行创建，否则，以后根据队列句柄使用消息队列的其它函数时会发生错误，用户通过消息队列句柄就可使用消息队列进行发送与获取消息的操作。

- 消息队列创建示例：

  ```c
  OS_Q  queue; //声明消息队列
  OS_ERR      err;
  /* 创建消息队列 queue */
  OSQCreate ((OS_Q         *)&queue,            //指向消息队列的指针
             (CPU_CHAR     *)"Queue For Test",  //队列的名字
             (OS_MSG_QTY    )20,                //最多可存放消息的数目
             (OS_ERR       *)&err);             //返回错误类型
  ```



### 消息队列删除函数OSQDel()

队列删除函数是根据队列结构（队列句柄）直接删除的，删除之后这个消息队列的所有信息都会被系统清空，而且不能再次使用这个消息队列了。需要注意的是，**如果某个消息队列没有被定义，那也是无法被删除的**。如果删除消息队列时，有任务正在等待消息，则不应该进行删除操作，删除之后的消息队列就不可用了。

- 如果任务是就绪状态、延时状态、挂起状态或者是在延时中被挂起，这些任务状态均与等待内核对象是无关的，在内核对象被删除的时候无需进行任何操作。

- 如果任务是无期限等待状态或者是有期限等待状态，那么在内核对象被删除的时候需要将这些任务恢复。

- 如果任务在无期限等待中被挂起或者在有期限等待中被挂起，也是需要将这些等待内核对象的任务从等待中移除，但是由于在等待中被挂起，那么就不会将这些任务恢复为就绪态，仅仅是将任务从等待列表中移除。

  ```c
  OS_Q queue; //声明消息队列
  OS_ERR err;
  /* 删除消息队列 queue */
  OSQDel ((OS_Q *)&queue, //指向消息队列的指针
          OS_OPT_DEL_NO_PEND,
          (OS_ERR *)&err); //返回错误类型
  ```



### 消息队列发送函数OSQPost()

**任务或者中断服务程序**都可以给消息队列发送消息，当发送消息时，如果队列未满， 就说明运行信息入队。uCOS-III会**从消息池中取出一个消息**，挂载到消息队列的**末尾**（FIFO 发送方式），如果是LIFO发送方式，则将消息挂载到消息队列的**头部**，然后**将消息中 MsgPtr 成员变量指向要发送的消息**（此处可以理解为添加要发送的信息到消息（块）中），如果系统有任务阻塞在消息队列中，那么在发送了消息队列的时候，会将任务解除阻塞。

> 我的理解：消息池就是提前创建好一些OS_MSG结构体的实例，后面需要创建消息时，直接从消息池中取出一个放入消息队列即可，通过修改NextPtr指针即可管理哪些消息实例属于当前消息队列。

发送消息的选项：

```c
#define OS_OPT_POST_FIFO (OS_OPT)(0x0000u) /* 默认采用FIFO 方式发送 */ 
#define OS_OPT_POST_LIFO (OS_OPT)(0x0010u) /* 采用LIFO 方式发送消息 */ 
#define OS_OPT_POST_1   (OS_OPT)(0x0000u)  /* 将消息发布到最高优先级的等待任务 */  
#define OS_OPT_POST_ALL (OS_OPT)(0x0200u)  /* 向所有等待的任务广播消息 */ 
  
#define OS_OPT_POST_NO_SCHED (OS_OPT)(0x8000u) /* 发送消息但是不进行任务调度 */
```

- 没有任务等待就直接将消息放入队列中即可，而有任务在等待则有可能需要唤醒该任务。

  如果有任务在等待消息，会有两种情况：

  - 一种是将消息发送到所有等待任务（广播消息）。
  - 另一种是只将消息发送到等待任务中最高优先级的任务。根据 opt 选项选择其中一种方式进行发送消息，如果要把消息发送给所有等待任务，那就首先获取到等待任务个数，保存在要处理任务个数 cnt 变量中。

```c
void  OS_QPost (OS_Q         *p_q,      //消息队列指针
                void         *p_void,   //消息指针
                OS_MSG_SIZE   msg_size, //消息大小（单位：字节）
                OS_OPT        opt,      //选项
                CPU_TS        ts,       //消息被发布时的时间戳
                OS_ERR       *p_err)    //返回错误类型
{
    OS_OBJ_QTY     cnt;
    OS_OPT         post_type;
    OS_PEND_LIST  *p_pend_list;
    OS_PEND_DATA  *p_pend_data;
    OS_PEND_DATA  *p_pend_data_next;
    OS_TCB        *p_tcb;
    CPU_SR_ALLOC();  //使用到临界段（在关/开中断时）时必需该宏，该宏声明和
					 //定义一个局部变量，用于保存关中断前的 CPU 状态寄存器
					 // SR（临界段关中断只需保存SR），开中断时将该值还原。

    OS_CRITICAL_ENTER();                              //进入临界段
    p_pend_list = &p_q->PendList;                     //取出该队列的等待列表
    
    /* 如果有任务在等待该队列 */
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {   //如果没有任务在等待该队列
        if ((opt & OS_OPT_POST_LIFO) == (OS_OPT)0) {  //把消息发布到队列的末端
            post_type = OS_OPT_POST_FIFO;
        } else {                                      //把消息发布到队列的前端
            post_type = OS_OPT_POST_LIFO;
        }
        OS_MsgQPut(&p_q->MsgQ,                        /* 把消息放入消息队列 */
                   p_void,
                   msg_size,
                   post_type,
                   ts,
                   p_err);
        OS_CRITICAL_EXIT();                          //退出临界段
        return;                                      //返回，执行完毕
    }
    
    /* 如果有任务在等待该队列 */
    if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {     //如果要把消息发布给所有等待任务
        cnt = p_pend_list->NbrEntries;              //获取等待任务数目
    } else {                                        //如果要把消息发布给一个等待任务
        cnt = (OS_OBJ_QTY)1;                        //要处理的任务数目为1
    }
    p_pend_data = p_pend_list->HeadPtr;             //获取等待列表的头部（任务）
    while (cnt > 0u) {                              //根据要发布的任务数目逐个发布
        p_tcb            = p_pend_data->TCBPtr;
        p_pend_data_next = p_pend_data->NextPtr;
        OS_Post((OS_PEND_OBJ *)((void *)p_q),       /* 把消息发布给任务 */
                p_tcb,
                p_void,
                msg_size,
                ts);
        p_pend_data = p_pend_data_next;
        cnt--;
    }
    OS_CRITICAL_EXIT_NO_SCHED();                     //退出临界段（无调度）
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) { //如果没选择“发布完不调度任务”
        OSSched();                                   //任务调度
    }
   *p_err = OS_ERR_NONE;                             //错误类型为“无错误”
}
```

- OS_MsgQPut() 函数用于将消息放入队列中

  `p_msg = OSMsgPool.NextPtr;`——从消息池获取一个消息（暂存于 p_msg），OSMsgPool 是消息池，它的 NextPtr 成员变量指向消息池中可用的消息。

  `OSMsgPool.NextPtr = p_msg->NextPtr;`——更新消息池中 NextPtr 成员变量，指向消息池中下一个可用的消息。

  `if (p_msg_q->NbrEntries == (OS_MSG_QTY)0)`——将获取的消息插入到消息队列时分两种情况：一种是队列中有消息情况，另一种是队列中没有消息情况。如果消息队列目前没有消息，将队列中的入队指针指向该消息，出队指针也指向该消息，因为现在消息放进来了，只有一个消息，无论是入队还是出队，都是该消息，更新队列的消息个数为 1，该消息的下一个消息为空。

  `if ((opt & OS_OPT_POST_LIFO) == OS_OPT_POST_FIFO)`——如果消息队列目前已有消息，那么又分两种入队的选项：

  - 如果采用 FIFO 方式插入队列，那么就将消息插入到入队端，消息队列的最后一个消息的 NextPtr 指针就指向该消息，然后入队的消息成为队列中排队的最后一个消息，那么需要更新它的下一个消息为空。
  - 如果采用 LIFO 方式插入队列，将消息插入到出队端，队列中出队指针 OutPtr 指向该消息，需要出队的时候就是该消息首先出队。

  ```c
  void  OS_MsgQPut (OS_MSG_Q     *p_msg_q,   //消息队列指针
                    void         *p_void,    //消息指针
                    OS_MSG_SIZE   msg_size,  //消息大小（单位：字节）
                    OS_OPT        opt,       //选项
                    CPU_TS        ts,        //消息被发布时的时间戳
                    OS_ERR       *p_err)     //返回错误类型
  {
      OS_MSG  *p_msg;
      OS_MSG  *p_msg_in;
  
  
  #ifdef OS_SAFETY_CRITICAL                //如果使能了安全检测
      if (p_err == (OS_ERR *)0) {          //如果错误类型实参为空
          OS_SAFETY_CRITICAL_EXCEPTION();  //执行安全检测异常函数
          return;                          //返回，停止执行
      }
  #endif
  
      if (p_msg_q->NbrEntries >= p_msg_q->NbrEntriesSize) { //如果消息队列已没有可用空间
         *p_err = OS_ERR_Q_MAX;                             //错误类型为“队列已满”
          return;                                           //返回，停止执行
      }
  
      if (OSMsgPool.NbrFree == (OS_MSG_QTY)0) {  //如果消息池没有可用消息
         *p_err = OS_ERR_MSG_POOL_EMPTY;         //错误类型为“消息池没有消息”  
          return;                                //返回，停止执行
      }
      
      /* 从消息池获取一个消息（暂存于 p_msg ）*/
      p_msg             = OSMsgPool.NextPtr;          //将消息控制块从消息池移除               
      OSMsgPool.NextPtr = p_msg->NextPtr;             //指向下一个消息（取走首个消息）
      OSMsgPool.NbrFree--;                            //消息池可用消息数减1
      OSMsgPool.NbrUsed++;                            //消息池被用消息数加1
      
      if (OSMsgPool.NbrUsedMax < OSMsgPool.NbrUsed) { //更新消息被用最大数目的历史记录
          OSMsgPool.NbrUsedMax = OSMsgPool.NbrUsed;
      }
      
      /* 将获取的消息插入到消息队列 */
      if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {             //如果消息队列目前没有消息
          p_msg_q->InPtr         = p_msg;                     //将其入队指针指向该消息
          p_msg_q->OutPtr        = p_msg;                     //出队指针也指向该消息
          p_msg_q->NbrEntries    = (OS_MSG_QTY)1;             //队列的消息数为1
          p_msg->NextPtr         = (OS_MSG *)0;               //该消息的下一个消息为空
      } else {                                                //如果消息队列目前已有消息
          if ((opt & OS_OPT_POST_LIFO) == OS_OPT_POST_FIFO) { //如果用FIFO方式插入队列，
              p_msg_in           = p_msg_q->InPtr;            //将消息插入到入队端，入队
              p_msg_in->NextPtr  = p_msg;                     //指针指向该消息。
              p_msg_q->InPtr     = p_msg;
              p_msg->NextPtr     = (OS_MSG *)0;
          } else {                                            //如果用LIFO方式插入队列，
              p_msg->NextPtr     = p_msg_q->OutPtr;           //将消息插入到出队端，出队
              p_msg_q->OutPtr    = p_msg;                     //指针指向该消息。
          }
          p_msg_q->NbrEntries++;                              //消息队列的消息数目加1
      }
      
      if (p_msg_q->NbrEntriesMax < p_msg_q->NbrEntries) {     //更新改消息队列的最大消息
          p_msg_q->NbrEntriesMax = p_msg_q->NbrEntries;       //数目的历史记录。
      }
      p_msg->MsgPtr  = p_void;                                //给该消息填写消息内容
      p_msg->MsgSize = msg_size;                              //给该消息填写消息大小
      p_msg->MsgTS   = ts;                                    //填写发布该消息时的时间戳
     *p_err          = OS_ERR_NONE;                           //错误类型为“无错误”
  }
  ```

- OS_Post() 函数负责把消息发送给任务

  ```c
  void  OS_Post (OS_PEND_OBJ  *p_obj,     //内核对象类型指针
                 OS_TCB       *p_tcb,     //任务控制块
                 void         *p_void,    //消息
                 OS_MSG_SIZE   msg_size,  //消息大小
                 CPU_TS        ts)        //时间戳
  {
      switch (p_tcb->TaskState) {                               //根据任务状态分类处理
          case OS_TASK_STATE_RDY:                               //如果任务处于就绪状态
          case OS_TASK_STATE_DLY:                               //如果任务处于延时状态
          case OS_TASK_STATE_SUSPENDED:                         //如果任务处于挂起状态
          case OS_TASK_STATE_DLY_SUSPENDED:                     //如果任务处于延时中被挂起状态
               break;                                           //不用处理，直接跳出
  
          case OS_TASK_STATE_PEND:                              //如果任务处于无期限等待状态
          case OS_TASK_STATE_PEND_TIMEOUT:                      //如果任务处于有期限等待状态
               if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {    //如果任务在等待多个信号量或消息队列
                   OS_Post1(p_obj,                              //标记哪个内核对象被发布
                            p_tcb,
                            p_void,
                            msg_size,
                            ts);
               } else {                                     //如果任务不是在等待多个信号量或消息队列
  #if (OS_MSG_EN > 0u)                                      //如果使能了任务队列或消息队列
                   p_tcb->MsgPtr  = p_void;                 //保存消息到等待任务
                   p_tcb->MsgSize = msg_size;                   
  #endif
                   p_tcb->TS      = ts;                     //保存时间戳到等待任务
               }
               if (p_obj != (OS_PEND_OBJ *)0) {             //如果内核对象为空
                   OS_PendListRemove(p_tcb);                /* 从等待列表移除该等待任务 */
  #if OS_CFG_DBG_EN > 0u                                    //如果使能了调试代码和变量 
                   OS_PendDbgNameRemove(p_obj,              //移除内核对象的调试名
                                        p_tcb);
  #endif
               }
               OS_TaskRdy(p_tcb);                               //让该等待任务准备运行
               p_tcb->TaskState  = OS_TASK_STATE_RDY;           //任务状态改为就绪状态
               p_tcb->PendStatus = OS_STATUS_PEND_OK;           //清除等待状态
               p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;     //标记不再等待
               break;
  
          case OS_TASK_STATE_PEND_SUSPENDED:                    //如果任务在无期限等待中被挂起
          case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:            //如果任务在有期限等待中被挂起
               if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {    //如果任务在等待多个信号量或消息队列
                   OS_Post1(p_obj,                              //标记哪个内核对象被发布
                            p_tcb,
                            p_void,
                            msg_size,
                            ts);
               } else {                                       //如果任务不在等待多个信号量或消息队列
  #if (OS_MSG_EN > 0u)                                        //如果使能了调试代码和变量
                   p_tcb->MsgPtr  = p_void;                   //保存消息到等待任务
                   p_tcb->MsgSize = msg_size;                     
  #endif
                   p_tcb->TS      = ts;                         //保存时间戳到等待任务
               }
               OS_TickListRemove(p_tcb);                        /* 从节拍列表移除该等待任务 */
               if (p_obj != (OS_PEND_OBJ *)0) {                 //如果内核对象为空
                   OS_PendListRemove(p_tcb);                    /* 从等待列表移除该等待任务 */
  #if OS_CFG_DBG_EN > 0u                                        //如果使能了调试代码和变量 
                   OS_PendDbgNameRemove(p_obj,                  //移除内核对象的调试名
                                        p_tcb);
  #endif
               }
               p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;     //任务状态改为被挂起状态
               p_tcb->PendStatus = OS_STATUS_PEND_OK;           //清除等待状态
               p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;     //标记不再等待
               break;
  
          default:                                              //如果任务状态超出预期
               break;                                           //直接跳出
      }
  }
  ```

  如果任务处于**就绪状态、延时状态、挂起状态或者是延时中被挂起状态**，都不用处理，直接退出，因为现在这个操作是内核对象进行发布（释放）操作，而这些状态的任务是与内核对象无关的状态，也就是这些任务没在等待相关的内核对象（如消息队列、信号量等）。

  如果任务处于**无期限等待状态或者是有期限等待状态**，那么就需要处理了，先看看任务是不是在等待多个内核对象。

  - 如果任务在等待多个信号量或消息队列，就调用 OS_Post1() 函数标记一下是哪个内核对象进行发布（释放）操作。

  - 如果任务不是在等待多个信号量或消息队列，直接操作即可。如果使能了任务队列或消息队列（OS_MSG_EN宏定义），保存消息到等待任务控制块的 MsgPtr 成员变量中，将消息的大小保存到等待任务控制块的 MsgSize 成员变量中。 

  - 如果内核对象不为空，调用 OS_PendListRemove() 函数**从等待列表移除该等待任务**。

  如果任务在**无期限等待中被挂起，或者任务在有期限等待中被挂起**，反正任务就是在等待中被挂起了，也能进行内核对象发布（释放）操作。同理，先看看任务是不是在等待多个内核对象。 

  - 如果任务在等待多个信号量或消息队列，就调用 OS_Post1() 函数标记一下是哪个内核对象进行发布（释放）操作。 
  - 如果任务不在等待多个信号量或消息队列，就直接操作即可。
  - 如果使能了任务队列或消息队列（使能了 OS_MSG_EN 宏定义），保存消息到等待任务控制块的 MsgPtr 成员变量中，将消息的大小保存到等待任务控制块的 MsgSize 成员变量中。 

  调用OS_TickListRemove()函数将任务**从节拍列表中移除**。

  从**等待列表移除**该等待任务。

  任务状态改为被挂起状态。

  清除任务的等待状态。

  标记任务不再等待。

- OSQPost() 使用实例：

  ```c
  /* 发布消息到消息队列 queue */
  OSQPost ((OS_Q        *)&queue,            //消息变量指针
           (void        *)"Fire uC/OS-III",  //要发送的数据的指针，将内存块首地址通过队列“发送出去”
           (OS_MSG_SIZE  )sizeof ( "Fire uC/OS-III" ),        //数据字节大小
           (OS_OPT       )OS_OPT_POST_FIFO | OS_OPT_POST_ALL, //先进先出和发布给全部任务的形式
           (OS_ERR      *)&err);	                            //返回错误类型
  ```



### 消息队列获取函数OSQPend()

**当任务试图从队列中获取消息时，用户可以指定一个阻塞超时时间**，当且仅当消息队列中有消息的时候，任务才能获取到消息。在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列消息有效。当**其他任务或中断服务程序往其等待的队列中写入了数据**，该任务将自动由**阻塞态转为就绪态**。当**任务等待的时间超过了用户指定的阻塞时间**，即使队列中尚无有效消息，任务也会自动从**阻塞态转为就绪态**。

- 当获取消息不成功的时候，用户选择了阻塞等待，那么就会将任务状态变为阻塞态以等待消息。 

- 判断一下调度器是否被锁，如果被锁了，则返回错误类型为“调度器被锁”的错误代码，然后退出。 **如果调度器未被锁，就锁定调度器，重新打开中断**。

  - ⭐️为什么刚刚调度器被锁就错误，而现在又要锁定调度器？

    因为之前锁定的调度器不是被这个函数锁定的，这是不允许的。因为**现在要阻塞当前任务，而调度器锁定了就表示无法进行任务调度**。那为什么又要关闭调度器呢，因为**接下来的操作是需要操作队列与任务的列表，这个时间就不会很短，系统不希望有其他任务来操作任务列表，因为可能引起其他任务解除阻塞，这可能会发生优先级翻转**。比如任务 A 的优先级低于当前任务，但是在当前任务进入阻塞的过程中，任务 A 却因为其他原因解除阻塞了，那系统肯定是会去运行任务 A，这显然是要绝对禁止的，因为挂起调度器意味着任务不能切换并且不准调用可能引起任务切换的 API 函数，所以，**锁定调度器，打开中断这样的处理，既不会影响中断的响应，又避免了其他任务来操作队列与任务的列表**。 

```c
void  *OSQPend (OS_Q         *p_q,       //消息队列指针
                OS_TICK       timeout,   //等待期限（单位：时钟节拍）
                OS_OPT        opt,       //选项
                OS_MSG_SIZE  *p_msg_size,//返回消息大小（单位：字节）
                CPU_TS       *p_ts,      //获取等到消息时的时间戳
                OS_ERR       *p_err)     //返回错误类型
{
    OS_PEND_DATA  pend_data;
    void         *p_void;
    CPU_SR_ALLOC(); //使用到临界段（在关/开中断时）时必需该宏，该宏声明和
                    //定义一个局部变量，用于保存关中断前的 CPU 状态寄存器
                    // SR（临界段关中断只需保存SR），开中断时将该值还原。

#ifdef OS_SAFETY_CRITICAL               //如果使能（默认禁用）了安全检测
    if (p_err == (OS_ERR *)0) {         //如果错误类型实参为空
        OS_SAFETY_CRITICAL_EXCEPTION(); //执行安全检测异常函数
        return ((void *)0);             //返回0（有错误），停止执行
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u         //如果使能了中断中非法调用检测
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) { //如果该函数在中断中被调用
       *p_err = OS_ERR_PEND_ISR;               //错误类型为“在中断中中止等待”
        return ((void *)0);                    //返回0（有错误），停止执行
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u                //如果使能了参数检测
    if (p_q == (OS_Q *)0) {               //如果 p_q 为空
       *p_err = OS_ERR_OBJ_PTR_NULL;      //错误类型为“对象为空”
        return ((void *)0);               //返回0（有错误），停止执行
    }
    if (p_msg_size == (OS_MSG_SIZE *)0) { //如果 p_msg_size 为空
       *p_err = OS_ERR_PTR_INVALID;       //错误类型为“指针不可用”
        return ((void *)0);               //返回0（有错误），停止执行
    }
    switch (opt) {                        //根据选项分类处理
        case OS_OPT_PEND_BLOCKING:        //如果选项在预期内
        case OS_OPT_PEND_NON_BLOCKING:
             break;                       //直接跳出

        default:                          //如果选项超出预期
            *p_err = OS_ERR_OPT_INVALID;  //返回错误类型为“选项非法”
             return ((void *)0);          //返回0（有错误），停止执行
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u        //如果使能了对象类型检测
    if (p_q->Type != OS_OBJ_TYPE_Q) {  //如果 p_q 不是消息队列类型
       *p_err = OS_ERR_OBJ_TYPE;       //错误类型为“对象类型有误”
        return ((void *)0);            //返回0（有错误），停止执行
    }
#endif

    if (p_ts != (CPU_TS *)0) {  //如果 p_ts 非空
       *p_ts  = (CPU_TS  )0;    //初始化（清零）p_ts，待用于返回时间戳
    }

    CPU_CRITICAL_ENTER();                                 //关中断
    p_void = OS_MsgQGet(&p_q->MsgQ,                       /* 从消息队列获取一个消息 */
                        p_msg_size,
                        p_ts,
                        p_err);
    if (*p_err == OS_ERR_NONE) {                          //如果获取消息成功
        CPU_CRITICAL_EXIT();                              //开中断
        return (p_void);                                  //返回消息内容
    }
    
    /* 如果获取消息不成功 !!!*/
    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {  //如果选择了不堵塞任务
        CPU_CRITICAL_EXIT();                              //开中断
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                  //错误类型为“等待渴求堵塞”
        return ((void *)0);                               //返回0（有错误），停止执行
    } else {                                              //如果选择了堵塞任务
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {  //如果调度器被锁
            CPU_CRITICAL_EXIT();                          //开中断
           *p_err = OS_ERR_SCHED_LOCKED;                  //错误类型为“调度器被锁”
            return ((void *)0);                           //返回0（有错误），停止执行
        }
    }
    
    /* 如果调度器未被锁 !!!*/                                
    OS_CRITICAL_ENTER_CPU_EXIT();                         //锁调度器，重开中断
    OS_Pend(&pend_data,                                   /* 堵塞当前任务，等待消息队列 */
            (OS_PEND_OBJ *)((void *)p_q),                 /* 将当前任务脱离就绪列表，并 */
            OS_TASK_PEND_ON_Q,                            /* 插入到节拍列表和等待列表。 */
            timeout);
    OS_CRITICAL_EXIT_NO_SCHED();                          //开调度器，但不进行调度

    OSSched();                                            //找到并调度最高优先级就绪任务
    
    /* 当前任务（获得消息队列的消息）得以继续运行 !!!*/
    CPU_CRITICAL_ENTER();                                 //关中断
    switch (OSTCBCurPtr->PendStatus) {                    //根据当前运行任务的等待状态分类处理
        case OS_STATUS_PEND_OK:                           //如果等待状态正常  
             p_void     = OSTCBCurPtr->MsgPtr;            //从（发布时放于）任务控制块提取消息
            *p_msg_size = OSTCBCurPtr->MsgSize;           //提取消息大小
             if (p_ts  != (CPU_TS *)0) {                  //如果 p_ts 非空
                *p_ts   =  OSTCBCurPtr->TS;               //获取任务等到消息时的时间戳
             }
            *p_err      = OS_ERR_NONE;                    //错误类型为“无错误”
             break;                                       //跳出

        case OS_STATUS_PEND_ABORT:                        //如果等待被中止
             p_void     = (void      *)0;                 //返回消息内容为空
            *p_msg_size = (OS_MSG_SIZE)0;                 //返回消息大小为0
             if (p_ts  != (CPU_TS *)0) {                  //如果 p_ts 非空
                *p_ts   =  OSTCBCurPtr->TS;               //获取等待被中止时的时间戳
             }
            *p_err      = OS_ERR_PEND_ABORT;              //错误类型为“等待被中止”
             break;                                       //跳出

        case OS_STATUS_PEND_TIMEOUT:                      //如果等待超时
             p_void     = (void      *)0;                 //返回消息内容为空
            *p_msg_size = (OS_MSG_SIZE)0;                 //返回消息大小为0
             if (p_ts  != (CPU_TS *)0) {                  //如果 p_ts 非空
                *p_ts   = (CPU_TS  )0;                    //清零 p_ts
             }
            *p_err      = OS_ERR_TIMEOUT;                 //错误类型为“等待超时”
             break;                                       //跳出

        case OS_STATUS_PEND_DEL:                          //如果等待的内核对象被删除
             p_void     = (void      *)0;                 //返回消息内容为空
            *p_msg_size = (OS_MSG_SIZE)0;                 //返回消息大小为0
             if (p_ts  != (CPU_TS *)0) {                  //如果 p_ts 非空
                *p_ts   =  OSTCBCurPtr->TS;               //获取对象被删时的时间戳
             }
            *p_err      = OS_ERR_OBJ_DEL;                 //错误类型为“等待对象被删”
             break;                                       //跳出

        default:                                          //如果等待状态超出预期
             p_void     = (void      *)0;                 //返回消息内容为空
            *p_msg_size = (OS_MSG_SIZE)0;                 //返回消息大小为0
            *p_err      = OS_ERR_STATUS_INVALID;          //错误类型为“状态非法”
             break;                                       //跳出
    }
    CPU_CRITICAL_EXIT();                                  //开中断
    return (p_void);                                      //返回消息内容
}
```

- OS_MsgQGet() 函数从消息队列获取一个消息

  ```c
  void  *OS_MsgQGet (OS_MSG_Q     *p_msg_q,     //消息队列
                     OS_MSG_SIZE  *p_msg_size,  //返回消息大小
                     CPU_TS       *p_ts,        //返回某些操作的时间戳
                     OS_ERR       *p_err)       //返回错误类型
  {
      OS_MSG  *p_msg;
      void    *p_void;
  
  #ifdef OS_SAFETY_CRITICAL               //如果使能（默认禁用）了安全检测
      if (p_err == (OS_ERR *)0) {         //如果错误类型实参为空
          OS_SAFETY_CRITICAL_EXCEPTION(); //执行安全检测异常函数
          return ((void *)0);             //返回空消息，停止执行
      }
  #endif
  
      if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {  //如果消息队列没有消息
         *p_msg_size = (OS_MSG_SIZE)0;             //返回消息长度为0
          if (p_ts != (CPU_TS *)0) {               //如果 p_ts 非空
             *p_ts  = (CPU_TS  )0;                 //清零 p_ts
          }
         *p_err = OS_ERR_Q_EMPTY;                  //错误类型为“队列没消息”
          return ((void *)0);                      //返回空消息，停止执行
      }
      
      /* 如果消息队列有消息 !!!*/
      p_msg           = p_msg_q->OutPtr;          //从队列的出口端提取消息           
      p_void          = p_msg->MsgPtr;            //提取消息内容
     *p_msg_size      = p_msg->MsgSize;           //提取消息长度
      if (p_ts != (CPU_TS *)0) {                  //如果 p_ts 非空
         *p_ts  = p_msg->MsgTS;                   //获取消息被发布时的时间戳
      }
  
      p_msg_q->OutPtr = p_msg->NextPtr;           //修改队列的出队指针
  
      if (p_msg_q->OutPtr == (OS_MSG *)0) {       //如果队列没有消息了
          p_msg_q->InPtr      = (OS_MSG   *)0;    //清零出队指针
          p_msg_q->NbrEntries = (OS_MSG_QTY)0;    //清零消息数
      } else {                                    //如果队列还有消息
          p_msg_q->NbrEntries--;                  //队列的消息数减1
      }
      
      /* 从消息队列提取完消息信息后，将消息释放回消息池供继续使用 !!!*/
      p_msg->NextPtr    = OSMsgPool.NextPtr;      /* 消息插回消息池，以便重复利用 */
      OSMsgPool.NextPtr = p_msg;
      OSMsgPool.NbrFree++;                        //消息池的可用消息数加1
      OSMsgPool.NbrUsed--;                        //消息池的已用消息数减1
  
     *p_err             = OS_ERR_NONE;            //错误类型为“无错误”
      return (p_void);                            //返回罅隙内容
  }
  ```
  
- OS_Pend() 函数将当前任务脱离就绪列表，并根据用户指定的阻塞时间插入到节拍列表和队列等待列表，然后打开调度器，但不进行调度。

  ```c
  void  OS_Pend (OS_PEND_DATA  *p_pend_data,  //待插入等待列表的元素
                 OS_PEND_OBJ   *p_obj,        //等待的内核对象
                 OS_STATE       pending_on,   //等待哪种对象内核
                 OS_TICK        timeout)      //等待期限
  {
      OS_PEND_LIST  *p_pend_list;
  
      OSTCBCurPtr->PendOn     = pending_on;                 //资源不可用，开始等待
      OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;          //正常等待中
  
      OS_TaskBlock(OSTCBCurPtr,                             /* 阻塞当前运行任务 */
                   timeout);                                /* 如果timeout非0，把任务插入节拍列表 */
  
      if (p_obj != (OS_PEND_OBJ *)0) {                      //如果等待对象非空
          p_pend_list             = &p_obj->PendList;       //获取对象的等待列表到 p_pend_list
          p_pend_data->PendObjPtr = p_obj;                  //保存要等待的对象
          OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,      /* 初始化p_pend_data（待插入等待列表）*/
                          (OS_PEND_DATA *)p_pend_data,
                          (OS_OBJ_QTY    )1);
          OS_PendListInsertPrio(p_pend_list,                /* 按优先级将p_pend_data插入到等待列表 */
                                p_pend_data);
      } else {                                                 //如果等待对象为空
          OSTCBCurPtr->PendDataTblEntries = (OS_OBJ_QTY    )0; //清零当前任务的等待域数据
          OSTCBCurPtr->PendDataTblPtr     = (OS_PEND_DATA *)0; 
      }
  #if OS_CFG_DBG_EN > 0u                                       //如果使能了调试代码和变量 
      OS_PendDbgNameAdd(p_obj,                                 //更新信号量的 DbgNamePtr 元素为其等待
                        OSTCBCurPtr);                          //列表中优先级最高的任务的名称。
  #endif
  }
  ```

- OSQPend() 使用实例

  ```c
  OS_Q queue; //声明消息队列 
  
  OS_ERR      err;
  OS_MSG_SIZE msg_size;
  
  /* 获取消息队列 queue 的消息 */ 
  pMsg = OSQPend ((OS_Q         *)&queue,             //消息变量指针
                  (OS_TICK       )0,                  //等待时长为无限
                  (OS_OPT        )OS_OPT_PEND_BLOCKING,  //如果没有获取到信号量就等待
                  (OS_MSG_SIZE  *)&msg_size,          //获取消息的字节大小
                  (CPU_TS       *)0,                  //获取任务发送时的时间戳
                  (OS_ERR       *)&err);              //返回错误
  ```

  

## 7. 消息队列使用注意事项

在使用 uCOS 提供的消息队列函数的时候，需要了解以下几点： 

1. 使用 OSQPend()、OSQPost() 等这些函数之前应先创建需消息队列，并根据队列句柄（队列控制块）进行操作。 

2. 队列读取采用的是先进先出（FIFO）模式，会先读取先存储在队列中的数据。当然也 uCOS 也支持后进先出（LIFO）模式，那么读取的时候就会读取到后进队列的数据。 

3. 无论是发送或者是接收消息都是以数据引用的方式进行。 
4. 队列是具有自己独立权限的内核对象，并不属于任何任务。所有任务都可以向同一队列写入和读出。一个队列由多任务或中断写入是经常的事，但由多个任务读出倒是用的比较少。 
5. **消息的传递实际上只是传递传送内容的指针和传送内容的字节大小**。这在使用消息队列的时候就要注意了，获取消息之前不能释放存储在消息中的指针内容，比如中断定义了一个局部变量，然后将其地址放在消息中进行传递，中断退出之前消息并没有被其他任务获取，退出中断的时候 CPU 已经释放了中断中的这个局部变量，后面任务获取这个地址的内容就会出错。所以**一定要保证在获取内容地址之前不能释放内容这个内存单元**。有三种方式可以避免这种情况： 

- 将变量**定义为静态变量**，即在其前面加上 static，这样内存单元就不会被释放。 

- 将变量**定义为全局变量**。 

- **将要传递的内容当做指针传递过去**。

  比如地址 0x12345678 存放一个变量的值为 5，常规是把 0x12345678 这个地址传递给接收消息的任务，任务接收到这个消息后，取出这个地址的内容 5。但是如果我们把 5 当做“地址”传递给任务，最后接收消息的任务直接拿着这个“地址”当做内容去处理即可。不过这种方法不能传递结构体等比较复杂的数据结构，因为消息中存放地址的变量内存大小是有限的（一个指针大小）。 



# 信号量

## 1\. 信号量基本概念

**信号量（Semaphore）是一种实现任务间通信的机制**，可以实现**任务之间同步**或**临界资源的互斥访问**，常用于协助一组相互竞争的任务来访问临界资源。在多任务系统中，各任务之间需要同步或互斥实现临界资源的保护，信号量功能可以为用户提供这方面的支持。 

抽象的来讲，信号量是一个非负整数，所有获取它的任务都会将该整数减一（获取它当然是为了使用资源），当该整数值为零时，所有试图获取它的任务都将处于阻塞状态。通常一个信号量的计数值用于对应有效的资源数，表示剩下可被占用的临界资源数，其值的含义分两种情况： 

- 0：表示没有积累下来的释放信号量操作，且有可能有在此信号量上阻塞的任务。 
- 正值，表示有一个或多个释放信号量操作。

**注意：uCOS 中的信号量不具备传递数据的功能。** 



### 二值信号量

二值信号量既可以用于**临界资源访问**也可以用于**同步**功能。 

二值信号量和互斥信号量（以下使用互斥量表示互斥信号量）非常相似，但是有一些细微差别：**互斥量有优先级继承机制，二值信号量则没有这个机制**。这使得二值信号量更偏向应用于同步功能（任务与任务间的同步或任务和中断间同步），而互斥量更偏向应用于临界资源的互斥访问。 

用作同步时，信号量在创建后应被置为空，任务 1 获取信号量而进入阻塞，任务 2 在某种条件发生后，释放信号量，于是任务 1 获得信号量得以进入就绪态，如果任务 1 的优先级是最高的，那么就会立即切换任务，从而达到了**两个任务间的同步**。同样的，**在中断服务函数中释放信号量，任务1 也会得到信号量，从而达到任务与中断间的同步**。

在裸机开发中我们经常是在中断中做一个标记，然后在退出的时候进行轮询处理，这个就是类似我们使用信号量进行同步的，当标记发生了，再做其他事情。**在 uCOS 中我们用信号量用于同步，任务与任务的同步，中断与任务的同步**，可以大大提高效率。 



### 计数信号量

在实际使用中，常将计数信号量用于**事件计数与资源管理**。每当某个事件发生时，**任务或者中断**将释放一个信号量（信号量计数值加 1），当处理被事件时（一般在任务中处理），处理任务会取走该信号量（信号量计数值减 1），**信号量的计数值则表示还有多少个事件没被处理。此外，系统还有很多资源，我们也可以使用计数信号量进行资源管理**，信号量的计数值表示系统中可用的资源数目，任务必须先获取到信号量才能获取资源访问权，当信号量的计数值为零时表示系统没有可用的资源，但是要注意，**在使用完资源的时候必须归还信号量**，否则当计数值为 0的时候任务就无法访问该资源了。 



## 2\. 信号量使用场景

**1、二值信号量是任务与任务、任务与中断间同步的重要手段**

在多任务系统中，经常会用到二值信号量，比如，某个任务需要等待一个标记，那么任务可以在**轮询**中查询这个标记有没有被置位，但是这样子做，就会很**消耗 CPU资源并且妨碍其它任务执行**。更好的做法是任务的大部分时间处于**阻塞**状态（允许其它任务执行），**直到某些事件发生该任务才被唤醒去执行**。可以使用二进制信号量实现这种同步，当任务取信号量时，因为此时尚未发生特定事件，信号量为空，任务会进入阻塞状态；当事件的条件满足后，任务/中断便会释放信号量，告知任务这个事件发生了，任务取得信号量便被唤醒去执行对应的操作，任务执行完毕并**不需要归还信号量**，这样子的 CPU 的效率可以大大提高，而且实时响应也是最快的。
再比如某个任务使用信号量等待中断的发生，在这之前任务已经进入了阻塞态，在等待着中断的发生，当在中断发生之后，释放一个信号量，也就是标记，在退出中断之后，操作系统会进行任务的调度，如果这个任务能够运行，系统就会去执行这个任务，这样子就大大提高了我们的效率。

- 二值信号量在**任务与任务**中同步的应用场景：

  假设我们有一个**温湿度传感器**，假设是 1s 采集一次数据，那么我们让他在**液晶屏**中显示数据出来，这个周期也是要 1s 一次的，**如果液晶屏刷新的周期是 100ms 更新一次，那么此时的温湿度的数据还没更新，液晶屏根本无需刷新**，只需要在 1s 后温湿度数据更新的时候刷新即可，否则 CPU 就是白白做了多次的无效数据更新，CPU 的资源就被刷新数据这个任务占用了大半，造成 CPU 资源浪费，如果液晶屏刷新的周期是 10s 更新一次，那么温湿度的数据都变化了 10 次，液晶屏才来更新数据，那拿这个产品有啥用，根本就是不准确的，所以，还是需要同步协调工作，在温湿度采集完毕之后，进行液晶屏数据的刷新，这样子，才是最准确的，并且不会浪费 CPU的资源。 

- 二值信号量在**任务与中断**同步的应用场景：

  我们在**串口接收**中，我们不知道啥时候有数据发送过来，有一个任务是做接收这些数据处理，总不能在任务中每时每刻都在任务查询有没有数据到来，那样会浪费 CPU 资源，所以在这种情况下使用二值信号量是很好的办法，当没有数据到来的时候，任务就进入阻塞态，不参与任务的调度，等到数据到来了，释放一个二值信号量，任务就立即从阻塞态中解除，进入就绪态，然后运行的时候处理数据，这样子系统的资源就会很好的被利用起来。 

  

**2、计数信号量则用于资源统计**

比如当前任务来了很多个消息，但是这些消息都放在缓冲区中，尚未处理，这时候就可以利用计数信号量对这些资源进行统计，每来一个消息就加一，每处理完一个消息就减一，这样子系统就知道有多少资源未处理的。 



## 3\. 二值信号量运作机制

创建信号量时，系统会为创建的信号量对象**分配内存**，并把**可用信号量初始化为用户自定义的个数**， 二值信号量的最大可用信号量个数为 1。

二值信号量获取：任何任务都可以从创建的二值信号量资源中获取一个二值信号量，获取成功则返回正确，否则任务会根据用户指定的**阻塞超时时间**来等待其它任务/中断释放信号量。在等待这段时间，系统将任务变成**阻塞**态，任务将被挂到该信号量的阻塞等待列表中。

- 信号量无效时候获取：在二值信号量无效的时候，假如此时有任务获取该信号量的话，那么任务将进入**阻塞**状态，如下图：

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200623221953.png" alt="image-20200623221104743" style="zoom:80%;" />

- 中断、任务释放信号量：假如某个时间中断/任务释放了信号量，其过程具体见下图：

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200623221956.png" alt="image-20200623221303147" style="zoom:80%;" />

- 二值信号量运作机制：由于获取无效信号量而进入阻塞态的任务将获得信号量并且恢复为就绪态，其过程具体见下图：

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200623221952.png" alt="image-20200623221313287" style="zoom:80%;" />



## 4\. 计数信号量运作机制

计数信号量可以用于**资源管理**，**允许多个任务获取信号量访问共享资源，但会限制任务的最大数目**。**访问的任务数达到可支持的最大数目时，会阻塞其他试图获取该信号量的任务**，直到有任务释放了信号量。这就是计数型信号量的运作机制，虽然计数信号量允许多个任务访问同一个资源，但是也有限定，比如某个资源限定只能有 3 个任务访问，那么第 4 个任务访问的时候，会因为获取不到信号量而进入阻塞，等到有任务（比如任务 1）释放掉该资源的时候，第 4 个任务才能获取到信号量从而进行资源的访问，其运作的机制具体见图 21-4。 

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200623221954.png" alt="image-20200623221458427" style="zoom: 67%;" />



## 5\. 信号量控制块

uCOS 的信号量由多个元素组成，在信号量被创建时，需要由我们自己定义信号量控制块（也可以称之为信号量句柄），因为它是用于保存信号量的一些信息的，其数据结构OS_SEM 除了信号量必须的一些基本信息外，还有 PendList 链表与 Ctr，为的是方便系统来管理信号量。

消息队列控制块：

<img src="https://gitee.com//MrRen-sdhm/Images/raw/master/img/20200623221955.png" alt="image-20200623221647094" style="zoom:80%;" />

```c
struct  os_sem {                        /* Semaphore */
    /* ------------------ GENERIC  MEMBERS ------------------ */
    OS_OBJ_TYPE          Type;          /* 信号量的类型 */
    CPU_CHAR            *NamePtr;       /* 信号量的名字 */
    OS_PEND_LIST         PendList;      /* 等待信号量的任务列表 */
#if OS_CFG_DBG_EN > 0u
    OS_SEM              *DbgPrevPtr;
    OS_SEM              *DbgNextPtr;
    CPU_CHAR            *DbgNamePtr;
#endif
    /* ------------------ SPECIFIC MEMBERS ------------------ */
    OS_SEM_CTR           Ctr;			/* 可用信号量的个数，如果为 0 则表示无可用信号量 */
    CPU_TS               TS;            /* 用于记录时间戳 */
};
```



## 6\. 信号量函数接口

### 创建信号量函数OSSemCreate()

### 信号量删除函数OSSemDel()

### 信号量释放函数OSSemPost()

### 信号量获取函数OSSemPend()



## 7\. 使用信号量的注意事项





# 互斥量



# 事件



# 软件定时器



# 任务信号量



# 任务消息队列



# 内存管理



# 中断管理